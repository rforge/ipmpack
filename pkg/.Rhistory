#
    #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)
reload.source()
#
    #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)#
    #
    quartz()#
    #all the two-ways, except those with islands.#
    explVar <- "y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl+x.unvacc.kids:x.hdi+x.unvacc.kids:x.nmigrants+x.hdi:x.nmigrants"#
    b0.1 <- checkBasicRelsBayes(dff,disease="rubella",explV=explVar,add=FALSE, interactions=TRUE)#
    b1.1 <- checkBasicRelsBayes(dff,disease="measles",explV=explVar,add=TRUE, interactions=TRUE)#
    b2.1 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE, interactions=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)#
    HistMedPopSizeExtremeGGplot(dff,b0.1,b1.1,b2.1)#
#
#
       quartz()#
    #all the two-ways#
    explVar <- "y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl+#
                      x.unvacc.kids:x.hdi+x.unvacc.kids:x.nmigrants+x.unvacc.kids:x.isl+#
                      x.hdi:x.nmigrants+ x.hdi:x.isl+x.nmigrants:x.isl"#
    b0.2 <- checkBasicRelsBayes(dff,disease="rubella",explV=explVar,add=FALSE)#
    b1.2 <- checkBasicRelsBayes(dff,disease="measles",explV=explVar,add=TRUE)#
    b2.2 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.2,b1.2,b2.2)#
    HistMedPopSizeExtremeGGplot(dff,b0.2,b1.2,b2.2)
reload.source()
   b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
  b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
reload.source()
   b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
reload.source()
   b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
  b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)\
  b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
   b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
   b2 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
reload.source()
   b2 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
   b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)
dataf=dff; disease="pertussis"
explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl"
assumeVaccNAzero=TRUE; add=TRUE; interactions=FALSE
  #chose disease#
    if (disease=="rubella") {#
        inc <- dataf$inc#
        name.disease <- matrix(disease,length(inc[,1]), length(inc[1,]))#
        vacc <- dataf$vacc/100#
        if (assumeVaccNAzero) vacc <- pmax(vacc,0,na.rm=TRUE)#
    }#
    if (disease=="pertussis") {#
        inc <- dataf$inc.pertussis#
        name.disease <- matrix(disease,length(inc[,1]), length(inc[1,]))#
        vacc <- dataf$vacc.pertussis/100#
        if (assumeVaccNAzero) vacc <- pmax(vacc,0,na.rm=TRUE)#
    }#
    if (disease=="mumps") {#
        inc <- dataf$inc.mumps#
        name.disease <- matrix(disease,length(inc[,1]), length(inc[1,]))#
        vacc <- dataf$vacc.mumps/100#
        if (assumeVaccNAzero) vacc <- pmax(vacc,0,na.rm=TRUE)#
    }#
    if (disease=="measles") {#
        inc <- dataf$inc.measles#
        name.disease <- matrix(disease,length(inc[,1]), length(inc[1,]))#
        vacc <- dataf$vacc.measles/100#
        if (assumeVaccNAzero) vacc <- pmax(vacc,0,na.rm=TRUE)#
    }#
        #
    #set up full set of covariates#
    Tmax <- length(inc[1,])#
    not.extinct.now <-  c(1*(inc[,1:(Tmax-1)]>0))#
    not.extinct.next <-  c(1*(inc[,2:Tmax]>0))#
    log.ppsize <- c(log(dataf$ppsize[,1:(Tmax-1)]))#
    prop.urban <- c(dataf$prop.urban[,1:(Tmax-1)])#
    island <- as.factor(c(dataf$island[,1:(Tmax-1)]))#
    disease.identity <- as.factor(c(name.disease[,1:(Tmax-1)]))#
    country <- rep(dataf$country,Tmax-1)#this works cos r concatenates by columns first#
    capitals <- c(dataf$capitals[,1:(Tmax-1)]) #
    hdi <- c(dataf$hdi[,1:(Tmax-1)])#
    gdp <- c(dataf$gdp[,1:(Tmax-1)])#
    travel <- c(dataf$travel[,1:(Tmax-1)])#
    n.urb <- c(dataf$n.urban.extent[,1:(Tmax-1)])#
    n.big.cities <- c(dataf$n.big.cities[,1:(Tmax-1)])#
    n.migrants <- c(dataf$n.migrants[,1:(Tmax-1)])#/c(dataf$area.km2[,1:(Tmax-1)])#
    n.flights <- c(dataf$n.incoming.flights[,1:(Tmax-1)])#
    yrs <- c(dff$years)#
    #
    #extras#
    log.unvacc.pop <- c(log(dataf$ppsize[,1:(Tmax-1)]*(1-vacc[,1:(Tmax-1)])))#
    log.unvacc.kids <- c(log((1/1000)*dataf$births[,1:(Tmax-1)]*dataf$ppsize[,1:(Tmax-1)]*(1-vacc[,1:(Tmax-1)])))#
 #
#
    ### FIT MODELS#
 #   subset <- which(not.extinct.now==0 & !is.na(not.extinct.next) &#
    subset <- which(not.extinct.now==1 & !is.na(not.extinct.next) &#
                    !is.na(log.unvacc.kids) & !is.na(island) & #
                    !is.na(n.migrants) & !is.na(hdi), arr.ind=TRUE)# & !is.na(prop.urban))#
    y <- 1-not.extinct.next[subset]#
    x.urb <- prop.urban[subset]#
    x.unvacc.pop <- log.unvacc.pop[subset]#
    x.pop <- exp(log.ppsize[subset])#
    x.isl <- as.factor(island[subset])#
    x.country <- country[subset]#
    x.capitals <- capitals[subset]#
    x.hdi <- hdi[subset]#
    x.gdp <- gdp[subset]#
    x.travel <- travel[subset]#
    x.nurb <- n.urb[subset]#
    x.nbig <- n.big.cities[subset]#
    x.unvacc.kids <- log.unvacc.kids[subset]#
    x.nmigrants <- log(n.migrants[subset])#
    x.nflights <- log(n.flights[subset])    #
    x.yrs <- c(yrs[subset])#
        #
    #center#
    x.urb<-x.urb-mean(x.urb,na.rm=TRUE)#
    x.nurb<-x.nurb-mean(x.nurb,na.rm=TRUE)#
    x.gdp <- x.gdp-mean(x.gdp,na.rm=TRUE)#
    x.nmigrants <- log(exp(x.nmigrants)/x.pop)  #convert migrants to fraction in pop#
   #if (interactions==TRUE) {#
       fit.present.detailed <- step(glm(as.formula(explV),family=binomial))#
    #print(summary(fit.present.detailed))#
   #} else { #
   #    fit.present.detailed <- glm(as.formula(explV),family=binomial)#
   #}#
    Formula <-  fit.present.detailed$formula#
#
##
    print(class(Formula))
Formula
b0[[1]]$formula
str(Formula)
str(b0[[1]]$formula)
  #plop in dataframe#
    data.here <- data.frame(y=y,#
                            x.unvacc.pop=x.unvacc.pop,#
                            x.unvacc.kids=x.unvacc.kids,#
                            x.hdi=x.hdi,#
                            x.nmigrants=x.nmigrants,x.isl=x.isl)#
#
  #
   #if (interactions==TRUE) {#
       fit.present.detailed <- step(glm(as.formula(explV),family=binomial, data=data.here))#
    #print(summary(fit.present.detailed))#
   #} else { #
   #    fit.present.detailed <- glm(as.formula(explV),family=binomial)#
   #}#
    Formula <-  fit.present.detailed$formula
Formula
     fit.present.detailed <- step(glm(as.formula(explV),family=binomial, data=data.here))#
    #print(summary(fit.present.detailed))
Formula
head(data.here)
formula(fit.present.detailed)
#
#
## Convenience function to bring in code - change path to where you have this file. #
reload.source <- function(){#
    source("/Users/cjessicametcalf/Documents/Rubella/source/GlobalMetapopRubella.R")#
}
reload.source()
dff<-getData()
#
    #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)
names(dff)
dff$unvacc.kids.rubella
names(dff)
reload.source()
  #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)
   #
    quartz()#
    #all the two-ways, except those with islands.#
    explVar <- "y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl+x.unvacc.kids:x.hdi+x.unvacc.kids:x.nmigrants+x.hdi:x.nmigrants"#
    b0.1 <- checkBasicRelsBayes(dff,disease="rubella",explV=explVar,add=FALSE, interactions=TRUE)#
    b1.1 <- checkBasicRelsBayes(dff,disease="measles",explV=explVar,add=TRUE, interactions=TRUE)#
    b2.1 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE, interactions=TRUE)
   #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)#
    HistMedPopSizeExtremeGGplot(dff,b0.1,b1.1,b2.1)
names(dff)
cor.test(c(dff$hdi),c(log(dff$unvacc.ppsize))
)
plot(c(dff$hdi),c(log(dff$unvacc.ppsize)))
plot(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.ppsize),na.rm=TRUE))
)
cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.ppsize),na.rm=TRUE)))
cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.ppsize.measles),na.rm=TRUE))))
names(dff)
cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.rubella),na.rm=TRUE))))
cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.rubella),na.rm=TRUE)))
 cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.rubella),na.rm=TRUE)))#
 cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.measles),na.rm=TRUE)))#
 cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.pertussis),na.rm=TRUE)))
cor.test(c(dff$hdi[,1]),c(rowMeans(log(dff$unvacc.pop.rubella),na.rm=TRUE))))
names( b0.1)
summary(b0.1[[1]])
summary(b1.1[[1]])
summary(b2.1[[1]])
   tmp<-predictFit(b1[[1]],dff,disease="rubella", just.odds=TRUE)
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)#
    HistMedPopSizeExtremeGGplot(dff,b0.1,b1.1,b2.1)
reload.source()
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)#
    HistMedPopSizeExtremeGGplot(dff,b0.1,b1.1,b2.1)
picGGplot(b0.1,b1.1,b2.1, ymax=5)
sumary(b0[[1]])
summary(b0[[1]])
summary(b0[[2]])
summary(b0[[3]])
  #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)
summary(b2[[3]])
summary(b2.1[[1]])
plot(b2.1[[1]])
plot(b2.1[[3]])
reload.source()
#
    #just main effects#
    b0 <- checkBasicRelsBayes(dff,disease="rubella", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=FALSE)#
    b1 <- checkBasicRelsBayes(dff,disease="measles", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
    b2 <- checkBasicRelsBayes(dff,disease="pertussis", explV="y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl",add=TRUE)#
#
    #picGGplot(b0,b1,b2, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0,b1,b2)#
    HistMedPopSizeExtremeGGplot(dff,b0,b1,b2)#
    #
    quartz()#
    #all the two-ways, except those with islands. CURRENT IMPLEMENTED#
    explVar <- "y~x.unvacc.kids+x.hdi+x.nmigrants+x.isl+x.unvacc.kids:x.hdi+x.unvacc.kids:x.nmigrants+x.hdi:x.nmigrants"#
    b0.1 <- checkBasicRelsBayes(dff,disease="rubella",explV=explVar,add=FALSE, interactions=TRUE)#
    b1.1 <- checkBasicRelsBayes(dff,disease="measles",explV=explVar,add=TRUE, interactions=TRUE)#
    b2.1 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE, interactions=TRUE)#
#
    #picGGplot(b0.1,b1.1,b2.1, ymax=5)#
    HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)#
    HistMedPopSizeExtremeGGplot(dff,b0.1,b1.1,b2.1)
plot(b2.1[[3]])
reload.source()
  b2.1 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE, interactions=TRUE)
plot(b2.1[[3]])
  HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)
reload.source()
  b2.1 <- checkBasicRelsBayes(dff,disease="pertussis",explV=explVar,add=TRUE, interactions=TRUE)
  HistMedPopSizeMedGGplot(dff,b0.1,b1.1,b2.1)
plot(b2.1[[3]])
summary(b2.1[[3]])
library(MCMCglmm)
?MCMCglmm
?predict.glm
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Util.r")
dff <- generateData()#
Tmatrix <- create.compound.Tmatrix(minSize = min(dff$size,na.rm=TRUE), maxSize = max(dff$size,na.rm = TRUE), envMatrix = makeEnvObj(dff), growObj = makeGrowthObj(dff, explanatoryVariables = "size+size2+covariate"), survObj = makeSurvObj(dff, explanatoryVariables = "size+size2+covariate"))
slotNames(Tmatrix)
makeFecObj
dff <- generateDataDiscrete()
table(dff$stage)
makediscreteTrans
create.IPM.Tmatrix
 makeListFmatrix
dff <- generateData()#
grlist <- makePostGrowthObjs(dff, explanatoryVariables="size",nitt = 5000)#
svlist <- makePostSurvivalObjs(dff, explanatoryVariables="size", nitt = 5000)
TmatrixList <- makeListTmatrix(grlist,svlist,#
		nBigMatrix=20,#
		minSize=-5,#
		maxSize=35)
res <- getIPMoutput(TmatrixList, targetSize=5, Fmatrixlist=NULL)#
names(res)
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")#
FmatrixList <- makeListFmatrix(fv,nBigMatrix=20,minSize=-5,maxSize=35,cov=FALSE)#
res <- getIPMoutput(TmatrixList,targetSize=5,FmatrixList)
length(FmatrixList )
getIPMoutput
length(Tmatrixlist)
TmatrixList
length(TmatrixList)
length(FmatrixList)
res <- getIPMoutput(TmatrixList[1:length(FmatrixList)],targetSize=5,FmatrixList)
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$ptime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$ptime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),type="l",lty=3)#
#
res$stable.size <- abs(Re(res$stable.size))#
res$stable.size <- res$stable.size/rowSums(res$stable.size)#
res$stable.size[!is.finite(res$stable.size) | is.na(res$stable.size)] <- 0#
CI <- apply(res$stable.size,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size), type="n",xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stable.size,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size, na.rm=TRUE),type="l",lty=3)#
#
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
names(res)
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$pTime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$pTime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],#
					 c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),type="l",lty=3)#
#
res$stable.size <- abs(Re(res$stableSize))#
res$stable.size <- res$stableSize/rowSums(res$stableSize)#
res$stable.size[!is.finite(res$stableSize) | is.na(res$stableSize)] <- 0#
CI <- apply(res$stableSize,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize), type="n",#
		xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stableSize,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize, na.rm=TRUE),type="l",lty=3)#
#
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$pTime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$pTime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],#
					 c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),type="l",lty=3)#
#
res$stableSize <- abs(Re(res$stableSize))#
res$stableSize <- res$stableSize/rowSums(res$stableSize)#
res$stableSize[!is.finite(res$stableSize) | is.na(res$stableSize)] <- 0#
CI <- apply(res$stableSize,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize), type="n",#
		xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stableSize,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize, na.rm=TRUE),type="l",lty=3)#
#
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
names(res)
res <- getIPMoutput(TmatrixList[1:length(FmatrixList)],targetSize=5,FmatrixList)
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$pTime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$pTime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],#
					 c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),type="l",lty=3)#
#
res$stableSize <- abs(Re(res$stableSize))#
res$stableSize <- res$stableSize/rowSums(res$stableSize)#
res$stableSize[!is.finite(res$stableSize) | is.na(res$stableSize)] <- 0#
CI <- apply(res$stableSize,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize), type="n",#
		xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stableSize,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stableSize, na.rm=TRUE),type="l",lty=3)#
#
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
names(res)
res <- getIPMoutput(TmatrixList[1:length(FmatrixList)],targetSize=5,FmatrixList)
Re(res$stableSize)
res$stableSize
names(res)
getIPMoutput
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$pTime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$pTime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],#
					 c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$pTime),type="l",lty=3)#
#
res$stableStage <- abs(Re(res$stableStage))#
res$stableStage <- res$stableStage/rowSums(res$stableStage)#
res$stableStage[!is.finite(res$stableStage) | is.na(res$stableStage)] <- 0#
CI <- apply(res$stableStage,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stableStage), type="n",#
		xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stableStage,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stableStage, na.rm=TRUE),type="l",lty=3)#
#
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
create.IPM.Tmatrix
length(fv)
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")
length(fv)
fv[[1]]
length(fv)
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Util.r")
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")
-MCMCglmm
MCMCglmm
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Util.r")
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Util.r")
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/IPMpack-Util.r")
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")
dff <- generateData()#
grlist <- makePostGrowthObjs(dff, explanatoryVariables="size",nitt = 5000)#
svlist <- makePostSurvivalObjs(dff, explanatoryVariables="size", nitt = 5000)
TmatrixList <- makeListTmatrix(grlist,svlist,#
		nBigMatrix=20,#
		minSize=-5,#
		maxSize=35,correction="constant")
res <- getIPMoutput(TmatrixList, targetSize=5, Fmatrixlist=NULL)#
names(res)
fv <- makePostFecObjs(dff, explanatoryVariables="size+size2", #
		nitt=10000,Transform="log")#
FmatrixList <- makeListFmatrix(fv,nBigMatrix=20,minSize=-5,maxSize=35,cov=FALSE, correction="constant")#
res <- getIPMoutput(TmatrixList[1:length(FmatrixList)],targetSize=5,FmatrixList)
length(FmatrixList)
length(TmatrixList)
#
#
## Build a function to get stoch rate increase#
##
##
TrackPopStruct <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.6,mag=0.8,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			nt.store<-matrix(NA,length(age.classes)*4,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				nt.store[,t]<-nt1#
				nt<-nt1#
				#
			}#
			#
			m.inds <- seq(1,length(age.classes)*4,by=4)#
			s.inds <- m.inds+1			#
			i.inds <- m.inds+2			#
			r.inds <- m.inds+3			#
#
			return(list(nt.store=nt.store,m.inds=m.inds,s.inds=s.inds,i.inds=i.inds,r.inds=r.inds,seasTrans=seasTrans))#
		}
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 3000:3200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")#
#
	#total pop size compare#
	plot(colSums(a1[[1]][,tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(b1[[1]][,tlim]), type="l",col=2)	#
#
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))#
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,100,200)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")
#
#
## Function to simulate evolution of maternal immunity   #########################
# Need: M, S, I, R classes, structured over age#
#  S gives birth to S#
#  I and R give birth to M#
#  I dies at a rate defined by age survival * mu.sick#
#  Infection rate imposed externally (because want to explore different periodicities, etc)#
#
# Parameter explored = duration maternal immunity #
# Potential extra adv - if you move into R maybe you have slightly higher mortality because part of your memory is tied up. #
#
# Do yearly time-step (cos why not)#
# Calculate lambda_s#
#
#
#
## Funtion to build survival T transitions#
## an infection #
# #
buildTMatrix <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0){#
#
	nage <- length(age.classes)#
	if (length(beta)==1) beta <- rep(beta,nage)#
	if (length(waning.immunity)==1) waning.immunity <- rep(waning.immunity,nage)	#
#
	waning.maternal<-exp(-waning.maternal.par*(age.classes))#
#
	mat1 <- matrix(0,4,4)#
#
	Tmat <- matrix(0,4*nage,4*nage)#
	for (j in 1:nage) { #
		#fill in epi matrix#
		mat1[] <- 0#
		mat1[1,1] <- waning.maternal[j]#
		mat1[2,1] <- 1-waning.maternal[j]#
		mat1[2,2] <- 1-beta[j]#
		mat1[3,2] <- beta[j]#
		mat1[4,3] <- 1#
		mat1[4,4] <- 1-waning.immunity[j]#
		mat1[2,4] <- waning.immunity[j]#
		#put in surv#
		surv <- rep(1-mort[j],4); surv[3] <- 1-(mu.sick*mort[j])#
		#fill in Tmatrix#
		if (j!=nage) { #
			Tmat[(j*4+1):(j*4+4),((j-1)*4+1):(j*4)] <- mat1*surv#
		} else { #
			Tmat[((j-1)*4+1):(j*4),((j-1)*4+1):(j*4)] <- mat1#
		}#
	}#
#
	return(Tmat)	#
#
}#
#
#
## Funtion to build fertility transitions#
## (prob only needs to happen once  #
# #
buildFMatrix <- function(age.classes=1:50,#
			fert=dnorm(1:50,25,5)){ 	#one for every age class#
	fert[age.classes<15] <- 0#
#
	nage <- length(age.classes)#
#
	Fmat <- matrix(0,4*nage,4*nage)#
	for (j in 1:nage) { #
		Fmat[1,((j-1)*4+1):(j*4)] <- c(0,0,fert[j],fert[j]) #the mat immune#
		Fmat[2,((j-1)*4+1):(j*4)]<- c(fert[j],fert[j],0,0) #the susceptible (mom didn't get sick)#
	}#
#
	return(Fmat)#
}#
#
#
#
#
## Build different yearly periodicity in trans#
##
periodTrans <- function(period=100,alpha=0.2,mag=0.01,Tmax=10000) { #
#
	u <- alpha*cos(2*pi*(1:Tmax)/period))#
	return(mag*(1+u))#
}#
#
#
## Build a function to get stoch rate increase#
##
##
StochGrowthRate <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.2,mag=0.01,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			Rt<-rep(NA,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				sum.nt1<-sum(nt1)#
				Rt[t]<-log(sum.nt1)#
				nt<-nt1/sum.nt1#
				#
			}#
			#
			res <- mean(Rt[n.runin:Tmax],na.rm=TRUE)#
			return(res)#
		}#
#
#
#
#
## Build a function to get stoch rate increase#
##
##
TrackPopStruct <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.6,mag=0.8,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			nt.store<-matrix(NA,length(age.classes)*4,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				nt.store[,t]<-nt1#
				nt<-nt1#
				#
			}#
			#
			m.inds <- seq(1,length(age.classes)*4,by=4)#
			s.inds <- m.inds+1			#
			i.inds <- m.inds+2			#
			r.inds <- m.inds+3			#
#
			return(list(nt.store=nt.store,m.inds=m.inds,s.inds=s.inds,i.inds=i.inds,r.inds=r.inds,seasTrans=seasTrans))#
		}#
#
#
#
picTrack <- function(){#
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 3000:3200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")#
#
	#total pop size compare#
	plot(colSums(a1[[1]][,tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(b1[[1]][,tlim]), type="l",col=2)	#
#
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))#
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,100,200)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
#
#
#
}
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 3000:3200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")#
#
	#total pop size compare#
	plot(colSums(a1[[1]][,tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(b1[[1]][,tlim]), type="l",col=2)	#
#
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))#
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,100,200)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")
#
#
#
## Build different yearly periodicity in trans#
##
periodTrans <- function(period=100,alpha=0.2,mag=0.01,Tmax=10000) { #
#
	u <- alpha*cos(2*pi*(1:Tmax)/period)#
	return(mag*(1+u))#
}
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 3000:3200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")#
#
	#total pop size compare#
	plot(colSums(a1[[1]][,tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(b1[[1]][,tlim]), type="l",col=2)	#
#
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))#
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,100,200)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")
a1[[1]][a1[[3]],]
a1[[1]][a1[[3]],1:10]
a1$seasTrans
#
#
## Build a function to get stoch rate increase#
##
##
StochGrowthRate <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.2,mag=0.01,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- pmax(pmin(periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax),1),0)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			Rt<-rep(NA,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				sum.nt1<-sum(nt1)#
				Rt[t]<-log(sum.nt1)#
				nt<-nt1/sum.nt1#
				#
			}#
			#
			res <- mean(Rt[n.runin:Tmax],na.rm=TRUE)#
			return(res)#
		}#
#
#
#
#
## Build a function to get stoch rate increase#
##
##
TrackPopStruct <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.6,mag=0.8,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- pmax(pmin(periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax),1),0)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			nt.store<-matrix(NA,length(age.classes)*4,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				nt.store[,t]<-nt1#
				nt<-nt1#
				#
			}#
			#
			m.inds <- seq(1,length(age.classes)*4,by=4)#
			s.inds <- m.inds+1			#
			i.inds <- m.inds+2			#
			r.inds <- m.inds+3			#
#
			return(list(nt.store=nt.store,m.inds=m.inds,s.inds=s.inds,i.inds=i.inds,r.inds=r.inds,seasTrans=seasTrans))#
		}
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 3000:3200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))
plot(a1[[1]][a1[[3]],3000],a1[[1]][a1[[4]],3000])
plot(a1[[1]][a1[[3]],3000],, type="l")
points(a1[[1]][a1[[4]],3000], type="l",col=2)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,100,200)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")
#
#
#run this#
a1<-SimTsir()#
plot(bws,bw.ev71[,3]/ur,type="b",col=1,xlab="Year",ylab="Cases (raw data)",xaxt="n", bty="n")#
lines(a1$Ival,type="l",lwd=1.2,col="blue")#
#axis(1,at=seq(13,312,by=26),labels=c("2000","2001","2002","2003","2004","2005","2006","2007","2008","2009","2010","2011"))#
#
#check susce#
plot(bws,St, xlab="year", ylab="inferred susc")#
lines(a1$Sval,type="l",lwd=1.2,col="blue")
	which(st==apply(st,2,max))
	which(st==apply(st,1,max))
	which(st==apply(st,1,max),arr.ind=T)
plot(st[1,])
plot(st[1,], type="l")
plot(st[2,], type="l")
	plot(st[,1],type="l")
	plot(st[,2],type="l")
	which(st==apply(st,2,max),arr.ind=T)
	which(t(st)==apply(st,1,max),arr.ind=T)
	which(t(st)==apply(st,2,max),arr.ind=T)
matplot(t(st))
matplot(t(st), type="l")
matplot((st), type="l")
wanes[1]
wanes[2]
matplot((st), type="b")
matplot((st), type="b",pch=19)
wanes[1:5]
plot(1:50,exp(-wanes[1]*(1:50)), type="l")
points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)
points(1:50,exp(-wanes[3]*(1:50)), type="l",col=3)
plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))
points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)
points(1:50,exp(-wanes[3]*(1:50)), type="l",col=3)
#
##
TrackPopStruct <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.1,	#1.01 how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.6,mag=0.8,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- pmax(pmin(periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax),1),0)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			nt.store<-matrix(NA,length(age.classes)*4,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				nt.store[,t]<-nt1#
				nt<-nt1#
				#
			}#
			#
			m.inds <- seq(1,length(age.classes)*4,by=4)#
			s.inds <- m.inds+1			#
			i.inds <- m.inds+2			#
			r.inds <- m.inds+3			#
#
			return(list(nt.store=nt.store,m.inds=m.inds,s.inds=s.inds,i.inds=i.inds,r.inds=r.inds,seasTrans=seasTrans))#
		}
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=50)#
	pd <- c(2,10,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot((st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
waneds[2]
wanes[2]
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.04,length=5)#
	pd <- c(2,10,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot((st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.04,length=5)#
	pd <- c(2,10,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot((st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.02,length=5)#
	pd <- c(2,10,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.01*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
#
		}}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.02,length=5)#
	pd <- c(2,10)#,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(wanes[j])#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
points(1:50,exp(-wanes[5]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,1,length=5)#
	pd <- c(2,10)#,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.6,length=5)#
	pd <- c(2,10)#,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 5000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.6,length=5)#
	pd <- c(2,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 3000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.3,length=5)#
	pd <- c(2,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 3000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.2,length=5)#
	pd <- c(2,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 3000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.05,length=5)#
	pd <- c(2)#,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 3000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.05,length=5)#
	pd <- c(2,100)#,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 3000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")
tlim<-2500:3000
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")
tlim<-2500:2700
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]][1:10],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]][1:10],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]][1:10],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]][1:10],tlim])), xlab="time", ylab="age",main="R")
a1[[2]]
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,c(1:(nrow(a1$nt.store)/4))[1:10],t(log(a1[[1]][a1[[2]][1:10],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,c(1:(nrow(a1$nt.store)/4))[1:10],t(log(a1[[1]][a1[[3]][1:10],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,c(1:(nrow(a1$nt.store)/4))[1:10],t(log(a1[[1]][a1[[4]][1:10],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,c(1:(nrow(a1$nt.store)/4))[1:10],t(log(a1[[1]][a1[[5]][1:10],tlim])), xlab="time", ylab="age",main="R")
#
#
## Function to simulate evolution of maternal immunity   #########################
# Need: M, S, I, R classes, structured over age#
#  S gives birth to S#
#  I and R give birth to M#
#  I dies at a rate defined by age survival * mu.sick#
#  Infection rate imposed externally (because want to explore different periodicities, etc)#
#
# Parameter explored = duration maternal immunity #
# Potential extra adv - if you move into R maybe you have slightly higher mortality because part of your memory is tied up. #
#
# Do yearly time-step (cos why not)#
# Calculate lambda_s#
#
#
#
## Funtion to build survival T transitions#
## an infection #
# #
buildTMatrix <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0){#
#
	nage <- length(age.classes)#
	if (length(beta)==1) beta <- rep(beta,nage)#
	if (length(waning.immunity)==1) waning.immunity <- rep(waning.immunity,nage)	#
#
	waning.maternal<-exp(-waning.maternal.par*(age.classes))#
#
	mat1 <- matrix(0,4,4)#
#
	Tmat <- matrix(0,4*nage,4*nage)#
	for (j in 1:nage) { #
		#fill in epi matrix#
		mat1[] <- 0#
		mat1[1,1] <- waning.maternal[j]#
		mat1[2,1] <- 1-waning.maternal[j]#
		mat1[2,2] <- 1-beta[j]#
		mat1[3,2] <- beta[j]#
		mat1[4,3] <- 1#
		mat1[4,4] <- 1-waning.immunity[j]#
		mat1[2,4] <- waning.immunity[j]#
		#put in surv#
		surv <- rep(1-mort[j],4); surv[3] <- 1-(mu.sick*mort[j])#
		#fill in Tmatrix#
		if (j!=nage) { #
			Tmat[(j*4+1):(j*4+4),((j-1)*4+1):(j*4)] <- mat1*surv#
		} else { #
			Tmat[((j-1)*4+1):(j*4),((j-1)*4+1):(j*4)] <- mat1#
		}#
	}#
#
	return(Tmat)	#
#
}#
#
#
## Funtion to build fertility transitions#
## (prob only needs to happen once  #
# #
buildFMatrix <- function(age.classes=1:50,#
			fert=dnorm(1:50,25,5)){ 	#one for every age class#
	fert[age.classes<15] <- 0#
#
	nage <- length(age.classes)#
#
	Fmat <- matrix(0,4*nage,4*nage)#
	for (j in 1:nage) { #
		Fmat[1,((j-1)*4+1):(j*4)] <- c(0,0,fert[j],fert[j]) #the mat immune#
		Fmat[2,((j-1)*4+1):(j*4)]<- c(fert[j],fert[j],0,0) #the susceptible (mom didn't get sick)#
	}#
#
	return(Fmat)#
}#
#
#
#
#
## Build different yearly periodicity in trans#
##
periodTrans <- function(period=100,alpha=0.2,mag=0.01,Tmax=10000) { #
#
	u <- alpha*cos(2*pi*(1:Tmax)/period)#
	return(mag*(1+u))#
}#
#
#
## Build a function to get stoch rate increase#
##
##
StochGrowthRate <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.01,	#how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.2,mag=0.01,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- pmax(pmin(periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax),1),0)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			Rt<-rep(NA,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				sum.nt1<-sum(nt1)#
				Rt[t]<-log(sum.nt1)#
				nt<-nt1/sum.nt1#
				#
			}#
			#
			res <- mean(Rt[n.runin:Tmax],na.rm=TRUE)#
			return(res)#
		}#
#
#
#
#
## Build a function to get stoch rate increase#
##
##
TrackPopStruct <- function(age.classes=1:50,#
			mort=c(0.18950, 0.04376, 0.02816, 0.01862, 0.01212, 0.00940, 0.00789, #
0.00682, 0.00589, 0.00568, 0.00601, 0.00574, 0.00546,0.00516, 0.00445, 0.00437, 0.00479, 0.00531, #
0.00556, 0.00554, 0.00584, 0.00675, 0.00759, 0.00702, 0.00653, 0.00650, 0.00652, 0.00685, 0.00858, #
0.00888, 0.00782, 0.00756, 0.00784, 0.00808, 0.00809, 0.00888, 0.00994, 0.00983, 0.00967, 0.00972,#
0.00994, 0.00948, 0.00948, 0.00953, 0.01012, 0.01049, 0.01065, 0.01109, 0.01130, 0.01152),   #one for every age class (danish 1835 cohort here)#
			mu.sick=1.1,	#1.01 how much more likely sick are to die#
			beta=c(0.1), #
			waning.maternal.par=1,#
			waning.immunity=0,#
			fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
			period=100,alpha=0.6,mag=0.8,Tmax=5000, n.runin=1000){#
			require(MASS)#
			#
			#get Fmatrix (won't change)#
			Fmat <- buildFMatrix(age.classes=age.classes,fert=fert)#
			#
			#get seasonal trans#
			seasTrans <- pmax(pmin(periodTrans(period=period,alpha=alpha,mag=mag,Tmax=Tmax),1),0)		#
#
			nt<-rep(0,length(age.classes)*4)#
			nt[1+seq(1,length(age.classes)*4,by=4)] <- 1#
			nt[2+seq(1,5*4,by=4)] <- 1#
			nt.store<-matrix(NA,length(age.classes)*4,Tmax)#
			#
			for (t in 1:Tmax) {#
				#build Tmat	#
				Tmat <- buildTMatrix(age.classes=age.classes,#
				mort=mort,   #one for every age class (danish 1835 cohort here)#
				mu.sick=mu.sick,	#how much more likely sick are to die#
				beta=seasTrans[t], #
				waning.maternal.par=waning.maternal.par,#
				waning.immunity=waning.immunity)#
#
				nt1<-(Tmat+Fmat) %*% nt	#
				nt.store[,t]<-nt1#
				nt<-nt1#
				#
			}#
			#
			m.inds <- seq(1,length(age.classes)*4,by=4)#
			s.inds <- m.inds+1			#
			i.inds <- m.inds+2			#
			r.inds <- m.inds+3			#
#
			return(list(nt.store=nt.store,m.inds=m.inds,s.inds=s.inds,i.inds=i.inds,r.inds=r.inds,seasTrans=seasTrans))#
		}#
#
#
#
picTrack <- function(){#
	a1<-TrackPopStruct(period=10)#
	b1<-TrackPopStruct(period=100)#
#
	par(mfrow=c(2,2),bty="l")#
	tlim <- 1000:1200#
	plot(colSums(a1[[1]][a1[[2]],tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(	b1[[1]][b1[[2]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[3]],tlim]), xlab="time", ylab="S", type="l")#
	points(colSums(	b1[[1]][b1[[3]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[4]],tlim]), xlab="time", ylab="I", type="l")#
	points(colSums(	b1[[1]][b1[[4]],tlim]), type="l", col=2)#
	plot(colSums(a1[[1]][a1[[5]],tlim]), xlab="time", ylab="R", type="l")#
	points(colSums(	b1[[1]][b1[[5]],tlim]), type="l", col=2)#
#
	par(mfrow=c(2,2)) #pop structure#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[2]],tlim])), xlab="time", ylab="age",main="M")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[3]],tlim])), xlab="time", ylab="age",main="S")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[4]],tlim])), xlab="time", ylab="age",main="I")#
	image(tlim,1:(nrow(a1$nt.store)/4),t(log(a1[[1]][a1[[5]],tlim])), xlab="time", ylab="age",main="R")#
#
	#total pop size compare#
	plot(colSums(a1[[1]][,tlim]), xlab="time", ylab="M", type="l")#
	points(colSums(b1[[1]][,tlim]), type="l",col=2)	#
#
	#highlights that problem with comparison across different seasonalities is that the more frequent have higher risk death anyway#
	mean(diff(colSums(a1[[1]][,tlim])))#
	mean(diff(colSums(b1[[1]][,tlim])))#
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.6,length=5)#
	pd <- c(2,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 2000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)#
#
#
#
}
#
#
	##compare across a range of periodicities three different wanings#
	wanes <- seq(1e-9,0.6,length=5)#
	pd <- c(2,50)#10,,50,100)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 2000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
wanes <- seq(1e-9,0.6,length=50)#
	pd <- c(2,10,50,100,500)#
	st <- matrix(NA,length(wanes),length(pd))#
	Tmax <- 2000#
	for (j in 1:length(wanes)) { #
		for (k in 1:length(pd)) { #
		a1<-TrackPopStruct(fert=0.1*dnorm(1:50,25,5)/max(dnorm(1:50,25,5)),#
				waning.maternal.par=wanes[j],period=pd[k],Tmax=Tmax,#
				mu.sick=1.5)#
		st[j,k] <- mean(diff(colSums(a1[[1]][,(Tmax-500):Tmax])))#
		}#
	print(j)#
	}#
	image(wanes,pd,(st),xlab="waning rate", ylab="periodicity of outbreaks")#
#
	matplot(wanes,(st), type="b",pch=19)#
#
	plot(1:50,exp(-wanes[1]*(1:50)), type="l", ylim=c(0,1))#
	points(1:50,exp(-wanes[2]*(1:50)), type="l",col=2)#
	points(1:50,exp(-wanes[3]*(1:50)), type="l",col=1)
#
setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
source("R/IPMpack-Util.R")#
source("R/IPMpack-Base.R")#
source("R/IPMpack-Impl.R")#
#
source("/Users/cjessicametcalf/Documents/IPM/source/TreesIndia-Util.R")#
source("/Users/cjessicametcalf/Documents/IPM/source/BeastiaryGrowthFunctions.R")
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    #get data#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizeNext - dff$size#
#
    survModels <- FigureTwo()#
    growModelsNeg <- FigureThree()#
    growModelsNoNeg <- FigureFour()#
    growModelsMech <- FigureFive()#
    #
 #
    #picture#
  #
    par(mfrow=c(1,2),bty="l")#
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)
  a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist,#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))#
    mtext(sp.names[1],side=3)
growModelsNoNeg$res1a$growthObjects
growModelsNoNeg$res1a$growthObjects[[1]]@fit[1]
names(growModelsNoNeg$res1a$growthObjects[[1]]@fit[1]=="(Intercept)"
)
growModelsNoNeg$res1a$growthObjects[[1]]@fit[1]=="(Intercept)"
growModelsNoNeg$res1a$growthObjects[[1]]@fit[1]=="Intercept"
growModelsNoNeg$res1a$growthObjects[[1]]@fit[1]
colnames(growModelsNoNeg$res1a$growthObjects[[1]]@fit[1])
names(growModelsNoNeg$res1a$growthObjects[[1]]@fit[1])
data.frame((Intercept)=rnorm(5)^0)
#
# growth for predicting next truncated incr #
setMethod("growth", #
		c("numeric","numeric","numeric","growthObj.truncincr"),#
		function(size,sizeNext,cov,growthObj){#
			require(truncnorm)#
			#
			newd <- data.frame(Intercept=size^0,#
					size=size,size2=size^2,size3=size^3,#
					logsize=log(size),logsize2=(log(size))^2,#
					covariate=as.factor(rep(cov,length(size))))#
			#
			#
			m1 <-match(names(growthObj@fit),colnames(newd)); #
			m1 <- c(1,m1[!is.na(m1)])#
			#
			mux <- colSums(t(newd[,m1])*growthObj@fit[1:(length(growthObj@fit)-1)])#
					#
			sigmax <- exp(growthObj@fit["logSigma"])#
			u <- dtruncnorm(sizeNext,a=size,b=Inf,mean=size+mux,sd=sigmax)  #
			return(u); #
		})
  a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist,#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))#
    mtext(sp.names[1],side=3)
#
#
# growth for predicting next truncated incr #
setMethod("growth", #
		c("numeric","numeric","numeric","growthObj.truncincr"),#
		function(size,sizeNext,cov,growthObj){#
			require(truncnorm)#
			#
			newd <- data.frame(Intercept=size^0,#
					size=size,size2=size^2,size3=size^3,#
					logsize=log(size),logsize2=(log(size))^2,#
					covariate=as.factor(rep(cov,length(size))))#
			#
			#
			m1 <-match(names(growthObj@fit),colnames(newd)); #
			m1 <- c(1,m1[!is.na(m1)])#
			print(m1)#
			mux <- colSums(t(newd[,m1])*growthObj@fit[1:(length(growthObj@fit)-1)])#
					#
			sigmax <- exp(growthObj@fit["logSigma"])#
			u <- dtruncnorm(sizeNext,a=size,b=Inf,mean=size+mux,sd=sigmax)  #
			return(u); #
		})
  a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist[9],#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))#
    mtext(sp.names[1],side=3)
#
FigureFour <- function(){#
#
    ## Bring in data#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
     dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
#
    #this is the time-adjusted#
    par(mfrow=c(2,3),bty="l",family = "Helvetica")#
#
    # 1. INCR-TRUNCATED#
    #this is the time-adjusted#
    dff$incr <- dff$sizeNext-dff$size#
    ylims1 <- pmax(range(dff$incr[dff$spcode==sp.list[1]],na.rm=TRUE)*c(1,1.5),-5)#
    ylims2 <- pmax(range(dff$incr[dff$spcode==sp.list[2]],na.rm=TRUE)*c(1,1.5),-5)#
    ylims3 <- pmax(range(dff$incr[dff$spcode==sp.list[3]],na.rm=TRUE)*c(1,1.5),-5)#
#
    res1a <- growthModelCompTruncincr(dff[dff$spcode==sp.list[1],],makePlot=TRUE,mainTitle=sp.names[1], ylim=ylims1)#
    addPdfGrowthPic(respType = "incr",sizesPlotAt=c(50,200,350),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=250,growthObjList=res1a[[2]][2:length(res1a[[2]])],cols=3:5,cov=1,minShow=0.05,lty=1)#
    res2a <- growthModelCompTruncincr(dff[dff$spcode==sp.list[2],],makePlot=TRUE,mainTitle=sp.names[2], ylim=ylims2)#
    addPdfGrowthPic(respType = "incr",sizesPlotAt=c(40,90,120),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=300,growthObjList=res2a[[2]][2:length(res1a[[2]])],cols=3:5,cov=1,minShow=1,lty=1)#
    res3a <- growthModelCompTruncincr(dff[dff$spcode==sp.list[3],],makePlot=TRUE,mainTitle=sp.names[3], ylim=ylims3)#
    addPdfGrowthPic(respType = "incr",sizesPlotAt=c(20,40,55),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=20,growthObjList=res3a[[2]][2:length(res1a[[2]])],cols=3:5,cov=1,minShow=0.05,lty=1)#
#
    #
    # 2. LOGINCR#
    #
    dff$logincr <- log(dff$sizeNext-dff$size)#
    dff$logincr[!is.finite(dff$logincr)] <- NA#
    ylims1 <-c(-10,10)#
    ylims2 <-c(-10,10)#
    ylims3 <- c(-10,10)#
    #
    res1 <- growthModelComp(dataf=dff[dff$spcode==sp.list[1],], makePlot=TRUE,respType="logincr", ylim=ylims1)#
    addPdfGrowthPic(respType = "logincr",sizesPlotAt=c(50,200,350),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=250,growthObjList=res1[[2]],cols=2:5,cov=1,minShow=0.05,lty=1)#
    res2 <- growthModelComp(dataf=dff[dff$spcode==sp.list[2],], makePlot=TRUE,respType="logincr", ylim=ylims2)#
    addPdfGrowthPic(respType = "logincr",sizesPlotAt=c(40,90,120),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=300,growthObjList=res2[[2]],cols=2:5,cov=1,minShow=1,lty=1)#
    res3 <- growthModelComp(dataf=dff[dff$spcode==sp.list[3],], makePlot=TRUE,respType="logincr", ylim=ylims3)#
    addPdfGrowthPic(respType = "logincr",sizesPlotAt=c(20,40,55),sizeRange=c(20,400),incrRange=c(-10,50),#
                    scalar=20,growthObjList=res3[[2]],cols=2:5,cov=1,minShow=0.05,lty=1)#
#
#
    return(list(res1=res1,res2=res2,res3=res3,res1a=res1a,res2a=res2a,res3a=res3a))#
#
}
   growModelsNoNeg <- FigureFour()
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist,#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
#
#
# growth for predicting next truncated incr #
setMethod("growth", #
		c("numeric","numeric","numeric","growthObj.truncincr"),#
		function(size,sizeNext,cov,growthObj){#
			require(truncnorm)#
			#
			newd <- data.frame(Intercept=size^0,blank=size*0,#
					size=size,size2=size^2,size3=size^3,#
					logsize=log(size),logsize2=(log(size))^2,#
					covariate=as.factor(rep(cov,length(size))))#
			#
			#
			m1 <-match(names(growthObj@fit),colnames(newd)); #
			m1 <- c(1,2,m1[!is.na(m1)])#
			#print(m1)#
			mux <- colSums(t(newd[,m1])*growthObj@fit[1:(length(growthObj@fit)-1)])#
					#
			sigmax <- exp(growthObj@fit["logSigma"])#
			u <- dtruncnorm(sizeNext,a=size,b=Inf,mean=size+mux,sd=sigmax)  #
			return(u); #
		})
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist,#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
#
# growth for predicting next truncated incr #
setMethod("growth", #
		c("numeric","numeric","numeric","growthObj.truncincr"),#
		function(size,sizeNext,cov,growthObj){#
			require(truncnorm)#
			#
			newd <- data.frame(Intercept=size^0,blank=size*0,#
					size=size,size2=size^2,size3=size^3,#
					logsize=log(size),logsize2=(log(size))^2,#
					covariate=as.factor(rep(cov,length(size))))#
			#
			#
			m1 <-match(names(growthObj@fit),colnames(newd)); #
			m1 <- c(2,1,m1[!is.na(m1)])#
			print(m1)#
			#print(m1)#
			mux <- colSums(t(newd[,m1])*c(0,growthObj@fit[1:(length(growthObj@fit)-1)]))#
					#
			sigmax <- exp(growthObj@fit["logSigma"])#
			u <- dtruncnorm(sizeNext,a=size,b=Inf,mean=size+mux,sd=sigmax)  #
			return(u); #
		})
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist[[9]],#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist[9],#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
#
# growth for predicting next truncated incr #
setMethod("growth", #
		c("numeric","numeric","numeric","growthObj.truncincr"),#
		function(size,sizeNext,cov,growthObj){#
			require(truncnorm)#
			#
			newd <- data.frame(blank=size*0,Intercept=size^0,#
					size=size,size2=size^2,size3=size^3,#
					logsize=log(size),logsize2=(log(size))^2,#
					covariate=as.factor(rep(cov,length(size))))#
			#
			#
			m1 <-match(names(growthObj@fit),colnames(newd)); #
			m1 <- c(1,2,m1[!is.na(m1)])#
			print(m1)#
			#print(m1)#
			mux <- colSums(t(newd[,m1])*c(0,growthObj@fit[1:(length(growthObj@fit)-1)]))#
					#
			sigmax <- exp(growthObj@fit["logSigma"])#
			u <- dtruncnorm(sizeNext,a=size,b=Inf,mean=size+mux,sd=sigmax)  #
			return(u); #
		})
#
    #species 1#
    grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist[9],#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
growth(1,rnorm(5),1,grlist[9])
grlist
growth(1,rnorm(5),1,grlist[[9]])
growth(1,rnorm(15),1,grlist[[9]])
growth(1,rnorm(15),1,grlist[[9]])
growth(1,rnorm(15),1,grlist[[9]])
growth(1,rnorm(15),1,grlist[[9]])
   grlist <- c(growModelsNeg$res1$growthObjects,growModelsNeg$res1a$growthObjects,#
                growModelsNoNeg$res1$growthObjects,growModelsNoNeg$res1a$growthObjects,#
                growModelsMech$res1$growthObject)#
    a1 <- compareTmatrices(dataf=dff[dff$spcode==sp.list[1],],log="y",#
                           growthObjList=grlist[9],#
                           survObjList=list(survModels$res1$survObjects[[2]]),#
                           nBigMatrix=300,chosenSize=1500,makePlot=TRUE,#
                           makeLegend=TRUE,#
                           legendNames=c(rep("sizeNext",2),#
                           rep("incr",3),rep("logincr",3),rep("truncincr",3),"Power","Monomolecular","Gompertz","Logistic3","Logistic4","Hossfeld"),#
                           cols=c(1,1,2,2,2,3,3,3,4,4,5,6,7,8,9,10))
growModelsNoNeg$res1a$growthObjects

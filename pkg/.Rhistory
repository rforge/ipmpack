  par(mfrow=c(1,3),bty="l", pty="s")#
    m1 <-  PowerLaw(dataf,plot=T)#
    m2 <-  getMonomolecular(dataf,plot=T)#
    m3 <-  getGompertz(dataf,plot=T)#
    m4 <-  getLogistic3(dataf,plot=T)#
    m5 <-  getLogistic4(dataf,plot=T)
   #
    par(mfrow=c(1,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dff,plot=T)#
    m2 <-  getMonomolecular(dff,plot=T)#
    m3 <-  getGompertz(dff,plot=T)#
    m4 <-  getLogistic3(dff,plot=T)#
    m5 <-  getLogistic4(dff,plot=T)
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dataf,plot=T); title("Power Law")#
    m2 <-  getMonomolecular(dataf,plot=T); title("Monomolecular")#
    m3 <-  getGompertz(dataf,plot=T); title("Gompertz")#
    m4 <-  getLogistic3(dataf,plot=T); title("Three parameter Logistic")#
    m5 <-  getLogistic4(dataf,plot=T); title("Four parameter Logistic")
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dff,plot=T); title("Power Law")#
    m2 <-  getMonomolecular(dff,plot=T); title("Monomolecular")#
    m3 <-  getGompertz(dff,plot=T); title("Gompertz")#
    m4 <-  getLogistic3(dff,plot=T); title("Three parameter Logistic")#
    m5 <-  getLogistic4(dff,plot=T); title("Four parameter Logistic")
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted")#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}
 m1 <-  getPowerLaw(dff,plot=T); title("Power Law")
m1
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n")
   #
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dataf,plot=T); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=T); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=T); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=T); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=T); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)
dataf<-dff
   #
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dataf,plot=T); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=T); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=T); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=T); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=T); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, xlims=c(0.1,10),ylim=c(-1,20)) {#
    #
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
## This file will containing a suite of different growth functions. For each, there will be#
# 1. a setClass#
# 2. a function predicting size or incr as function size and parameters#
# 3. a likelihood function that can be fed this function and data to optim#
# 3. a growth method for the midpoint rule, and for the cumulative rule#
#
#
# Currently forms are taken from last column in Table 1, Paine et al. MEE, 2011#
#
## THE GOMPERTZ ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Gompertz",#
         representation(paras="numeric",#
                        sd="numeric",#
                        logLik="numeric"))#
#
# Function#
Gompertz <- function(size,paras) {#
    u <- size*paras[1]*log(paras[2]/size)#
    return(u)#
}#
#
#
# Likelihood for optim#
wrapGompertz <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Gompertz(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    #ss <- sum((dataf$incr[!is.na(dataf$incr) & !is.na(dataf$size)]/#
    #           dataf$size[!is.na(dataf$incr) & !is.na(dataf$size)]-#
    #           pred[!is.na(dataf$incr) & !is.na(dataf$size)])^2)#
    #return(ss)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function using max like#
getGompertz <- function(dataf, par=c(8e-4,2.5,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapGompertz, dataf=dataf, method="Nelder-Mead")#
    print(tmp)#
    gr1 <- new("growthObj.Gompertz")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Gompertz(size=dataf$size, paras=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
    return(gr1)#
}#
#
#
# Create wrapper to fit and return a Gompertz growth function using gnls (to allow for heterosc)#
#Gompertz function with named parameters...#
Gompertz2 <- function(X,para1,para2) {#
    para1 <- exp(para1)#
    para2 <- exp(para2)#
    u <- X*para1*log(para2/X)#
    return(u)#
}#
#gnls wrapper#
getGompertz.gnls <- function(dataf,  plot=FALSE) {#
    #prepare data#
    dat.asymp <- data.frame(Y=dataf$incr,X=dataf$size)#
    dat.asymp <- dat.asymp[!is.na(dat.asymp$X) & !is.na(dat.asymp$Y),]#
    dat.asymp <- dat.asymp[dat.asymp$Y>0,]#
    #starting values#
    a1<-getGompertz(dff,plot=T)#
    #fit#
    fit.gomp <- gnls(Y ~ Gompertz2(X, para1,para2),#
                     start=log(c(para1=a1@paras[1],para2=a1@paras[2])),#
                     data = dat.asymp, weights= varExp(form = ~ fitted(.)),#
                     control=gnlsControl(nlsTol=0.1))#
    out.gomp <- output.gomp.gnls(fit.gomp, Xes_asymp$X, CI = T)#
#
    #put this into a growth object#
    #gr1 <- new("growthObj.Gompertz.hetersc")#
    #gr1@paras <- exp(tmp$par[1:2])#
    #gr1@sd <- exp(tmp$par[3])#
    #gr1@logLik <- -tmp$value#
#
}#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Gompertz"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Gompertz"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
## THE FOUR PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic4",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic4 <- function(size,paras) {#
    u <- (paras[1]*(size-paras[3]))*((paras[2]-size)/(paras[2]-paras[3]))#
    return(u)#
}#
#
#
# Likelihood for optim#
wrapLogistic4 <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Logistic4(dataf$size, paras=par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return #
getLogistic4 <- function(dataf, par=c(0.02,10,0.001,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic4, dataf=dataf, method="Nelder-Mead")  #
    print(tmp)#
     gr1 <- new("growthObj.Logistic4")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
    #
    if(plot) {#
        pred <- Logistic4(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
    return(gr1)#
}#
#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic4"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic4"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
## THE THREE PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic3",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic3 <- function(size,paras) {#
    size*(paras[1]*(1-size/paras[2]))#
}#
#
#
# Likelihood for optim#
wrapLogistic3 <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Logistic3(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getLogistic3 <- function(dataf, par=c(0.2,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic3, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Logistic3")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Logistic3(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic3"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic3"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
## THE MONOMOLECULAR ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Monomolecular",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Monomolecular <- function(size,paras) {#
    paras[1]*(paras[2]-size)#
}#
#
#
# Likelihood for optim#
wrapMonomolecular <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Monomolecular(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getMonomolecular <- function(dataf, par=c(0.002,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapMonomolecular, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Monomolecular")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Monomolecular(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Monomolecular"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Monomolecular"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
###### POWER-LAW #######################################
#
# Create a generic growth object  #
setClass("growthObj.PowerLaw",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
PowerLaw <- function(size,paras) {#
    paras[1]*(size^paras[2])#
}#
#
#
# Likelihood for optim#
wrapPowerLaw <- function(par, dataf) {#
    par <- exp(par)#
    pred <- PowerLaw(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, xlims=c(0.1,10),ylim=c(-1,20)) {#
    #
    par(mfrow=c(2,3),bty="l", pty="s")#
    m1 <-  getPowerLaw(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(3,5),bty="l")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, xlims=c(0.1,10),ylim=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(3,5),bty="l")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=TRUE, xlim=xlims,ylim=ylims); title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(3,5),bty="l")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf,plot=plot, xlim=xlims,ylim=ylims); if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
    m2 <-  getMonomolecular(dataf,plot=plot, xlim=xlims,ylim=ylims); if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
    m3 <-  getGompertz(dataf,plot=plot, xlim=xlims,ylim=ylims); if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
    m4 <-  getLogistic3(dataf,plot=plot, xlim=xlims,ylim=ylims); if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
    m5 <-  getLogistic4(dataf,plot=plot, xlim=xlims,ylim=ylims); if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
     par(mfrow=c(3,5),bty="l")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
getPowerLaw
res1
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1),#
                       plot=plot, xlim=xlims,ylim=ylims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1),#
                            plot=plot, xlim=xlims,ylim=ylims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,par=c(),#
                       plot=plot, xlim=xlims,ylim=ylims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot, xlim=xlims,ylim=ylims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot, xlim=xlims,ylim=ylims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1),#
                       plot=plot,ylim=ylims, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1),#
                            plot=plot,ylim=ylims, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,par=c(),#
                       plot=plot,ylim=ylims, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,par=c(),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,par=c(),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])
makeGrowthObjGeneral
  sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,exp(vals),order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", logLik=",round(vals,1), sep="")),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.7,bg="white")#
     #
    }#
             #
#
    #
}
  sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
?legend
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,exp(vals),order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", logLik=",round(vals,1), sep="")),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.7,bg="white",box.col="white")#
     #
    }#
             #
#
    #
}
  sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,exp(vals),order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", logLik=",round(vals,1), sep="")),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
   par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
#
##### FUNCTIONS USED IN ANALYZING DATA FROM: http://esapubs.org/archive/ecol/E092/115/default.htm#data #
#
#
#setwd("/Users/jessicametcalf/Dropbox/IPMpack_folder/IPMpack/")#
#reload.source(filename="R/")#
#
#
## Function to alter vector from status description to#
# 0s and 1s#
##
convertStatus <- function(x) {#
    y <- rep(NA,length(x))#
    y[x=="A"] <- 1#
    y[x=="D"] <- 0#
    y[x=="P"] <- 1 #this is a future tree, usuall no size, but prob alives, but these are not evenly sampled#
#
    return(y)#
}#
#
#
## Function to sort out names, create codes, etc#
##  - dumped out now, so don't need to re-run! - #
###
getSp <- function(filename="data/"){#
#
    #write out species names - takes by hand editing so only do once#
    det <-  read.delim(paste(filename,"SpeciesDetails.txt", sep=""),header=TRUE)#
    genus.end <-  regexpr(" ", det[,2]);#
    mat <- cbind(as.character(det$Family), substr(det$LatinName,1,genus.end),#
                 as.character(det$LatinName))#
    write.table(paste(mat[,1],"/",mat[,2],"/",mat[,3], sep=""),#
                file="names.sp",row.names=FALSE, quote = FALSE)#
    #remember, make lower case, put _ between genus and species name, remove " /"#
    #
    #
#
}#
#
#
## Function to pull in all the data taken from#
## http://esapubs.org/archive/ecol/E092/115/default.htm#data#
## Ecological Archives, E092-115-D1.#
## and organize it into a format recognized by IPMpack#
##
# parameters - filename - file describing location of the data#
#            - species - chosen species (four letter code) or "all"#
##
# returns - a data-frame with headings size, sizenext (adjusted for time interval),#
#                incr (raw increment), surv (survival), spcode,#
#              and exactDate and exactDatel in days#
##
getData <- function(filename="data/",#
                    species="vain"){#
#
    #bring in the data#
    df <- read.delim(paste(filename,"WesternGhatTrees.txt", sep=""),header=TRUE)#
    if (species!="all") df <- df[df$SpCode==species,]#
#
    #
    #get matrix of dates, sizes, survival #
    dates.raw <- cbind(df$Date0,df$Date1,df$Date2, df$Date3, df$Date4, df$Date5)  #
    sizes.raw <- cbind(df$GBH0,df$GBH1,df$GBH2,df$GBH3,df$GBH4,df$GBH5)#
    surv.raw <- cbind(convertStatus(df$Status0),convertStatus(df$Status1),convertStatus(df$Status2),#
                   convertStatus(df$Status3),convertStatus(df$Status4),convertStatus(df$Status5))#
#
    #get the raw increment for fitting detailed survival model#
    incr <- cbind(df$GBH1-df$GBH0,df$GBH2-df$GBH1,df$GBH3-df$GBH2,df$GBH4-df$GBH3,df$GBH5-df$GBH4)#
    #
    #loop over, predict sizes at days closest to 365*4 (bi-yearly intrvals)#
    pred.dates <- (365*4)*c(0:5)#
    predict.sizes <- matrix(NA,length(df[,1]),length(pred.dates))#
    predict.surv <- matrix(1,length(df[,1]),length(pred.dates))#
        #
    for (k in 1:length(df[,1])) {#
        x <- as.numeric(dates.raw[k,])#
        y <- sizes.raw[k,]#
#
        bad <- is.na(x) | is.na(y)#
        x <- x[!bad]#
        y <- y[!bad]#
     #
        #linear regression#
        if (length(x)<4) { #
            fit <- lm(y~x)#
            predict.sizes[k,] <- predict(fit,newdata=data.frame(x=pred.dates)) #linear reg#
        } else { #
        #smooth spline#
            fit <- smooth.spline(y~x)#
            predict.sizes[k,] <- predict(fit,x=pred.dates)$y #smooth spline#
        }#
            #
        bad <- which(pred.dates>max(x,na.rm=TRUE), arr.ind=TRUE)#
        if (length(bad)>0) predict.sizes[k,bad] <- NA#
        #
        dead <- dates.raw[k,surv.raw[k,]==0][1]#
        loc.dead <- which((dead-pred.dates)^2==min((dead-pred.dates)^2), arr.ind=TRUE)#
        if (length(loc.dead)>0) predict.surv[k,loc.dead:length(pred.dates)] <- 0              #
    }#
#
    #reassure yourself it might work#
#    matplot(t(dates.raw),t(sizes.raw), type="b", pch=19,xlab="dates", ylab="sizes")#
#    abline(v=pred.dates)#
#
        #
    dataf <- data.frame(size=c(predict.sizes[,1:5]),sizenext=c(predict.sizes[,2:6]),#
                        incr=c(incr[,1:5]),#
                        surv=c(predict.surv[,2:6]), spcode=rep(df$SpCode, 5),#
                        exactDate=c(dates.raw[,1:5]), exactDatel=c(dates.raw[,2:6]))#
#
    dataf <- dataf[!is.na(dataf$size),]#
    #
    return(dataf)#
#
}#
#
#
#
#
#
#
## Function to fit survival with varying time increments and then write parameters#
## over onto a classic glm framework. #
##
# parameters - dataf - a dataframe including columns#
#                  size, surv, exactDate, and exactDatel, the latter two in days#
#            - nyrs - desired number of years in a time-step#
#            - par - starting values for the parameters#
#                     (must be of length one longer than cov.names,#
#                       given intercept)#
#            - cov.names - names of chosen covariates#
#            - method - method for optim ("Nelder-Mead", "SANN", etc.)#
##
# Returns  - output of optim#
##
fitSurvVaryingTimeIntervals <- function(dataf,#
                                        nyrs=5,#
                                        par=c(0.01,0.01,0.01,0.01),#
                                        cov.names=c("size","size2","size3"),#
                                        method="Nelder-Mead") {#
#
    #warnings#
    if ((length(par)-1)!=length(cov.names)) {#
        print("starting values does not match length of covariate names")#
    }#
#
    #make sure you have all the right covariates#
    if (length(cov.names)>0) { #
        if (length(grep("size2",cov.names))>0) dataf$size2 <- (dataf$size)^2#
        if (length(grep("size3",cov.names))>0) dataf$size3 <- (dataf$size)^3#
        if (length(grep("logsize",cov.names))>0) dataf$logsize <- log(dataf$size)#
        if (length(grep("logsize2",cov.names))>0) dataf$logsize2 <- (log(dataf$size))^2#
    }#
    #
    tmp <- optim(par,likeSurvVaryingTimeIntervals,#
                 cov.names=cov.names,nyrs=nyrs,dataf=dataf,#
                 method=method)#
#
    #
    if (tmp$convergence!=0) {#
        tmp <- optim(tmp$par,likeSurvVaryingTimeIntervals,#
                     cov.names=cov.names,nyrs=nyrs,dataf=dataf,#
                     method=method)#
        if (tmp$convergence!=0)  print("not converged")        #
    }#
    #
    #write template over the top#
    if (length(cov.names)>0) formula <- as.character(paste("surv~",paste(cov.names,collapse="+"),collapse="")) else formula <- as.character("surv~1")#
    fit <- glm(formula,data=dataf,family=binomial)#
    #print(fit)#
    fit$coefficients <- tmp$par#
#
    sv1 <- new("survObj")#
    sv1@fit <- fit#
#
    tmp$sv1 <- sv1#
    #
#
    return(tmp)#
#return(list(tmp=tmp,sv1=sv1))#
#
}#
#
#Function to calculate the likelihood for variable time-intervals for survival #
##
# parameters #
#            - par - starting values for the parameters#
#                     (must be of length one longer than cov.names,#
#                       given intercept)#
#            - cov.names - names of chosen covariates#
#            - nyrs - desired number of years in a time-step#
#            - dataf - a dataframe including columns in cov.names, as well as#
#                  size, surv, exactDate, and exactDatel, the latter two in days#
##
# Returns  - numeric equal to minus the log likelihood#
##
likeSurvVaryingTimeIntervals <- function(par=c(0.01,0.01,0.01,0.01),#
                                         cov.names=c("size","size2","size3"),#
                                         nyrs=5,#
                                         dataf) {#
#
    #
    #define time change#
    tdiff <- (dataf$exactDatel-dataf$exactDate)/(nyrs*365)#
    #print(range(tdiff, na.rm=TRUE))#
#
    #build predictor#
    if (length(cov.names)>0) {#
        pred <-  t(t(dataf[,cov.names])*par[2:length(par)])#
    }else { pred <- matrix(0,nrow(dataf),1)}#
    pred <- par[1] + rowSums(pred)#
    pred[pred>200] <- 200  #don't want bigger than exp(200) - gets infinite really quick#
    pred <- (exp(pred)/(1+exp(pred)))^(tdiff)#
    #
    #estimate likelihood#
    like <- dbinom(dataf$surv,1,pred, log=TRUE)#
    #like[like==-Inf] <- -exp(500)#
    #like[like==Inf] <- exp(500)#
#
    sumRows <- rep(0,nrow(dataf))#
    if (length(cov.names)>1) sumRows <- rowSums(dataf[,cov.names])#
    if (length(cov.names)==1) sumRows <- dataf[,cov.names]#
    #
    return(-sum(like[!is.na(sumRows) & !is.na(dataf$surv)],na.rm=TRUE))#
    #
}#
#
#
## Make Figure 1- showning basic qualities of the data ####
## for three species with sufficient mortality info ######
##
FigureOne <- function(){#
#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    #
    # 1. create exact times figure#
    par(mfrow=c(1,3),bty="l")#
    brks <- c(-0.5,1.5,2.5,3.5,4.5,5.5)#
    #
    for (k in 1:length(sp.list)) {#
        a1<-hist(c(dff$exactDatel[dff$spcode==sp.list[k]]-dff$exactDate[dff$spcode==sp.list[k]])/365,#
        breaks=brks, plot=FALSE)#
        if (k==1) cts <- a1$counts#
        if (k>1) cts <- rbind(cts,a1$counts)#
    #
    }#
#
    barplot(cts,beside=TRUE, names.arg=c("<1","2","3","4","5"), xlab="Census interval (years)")#
    legend("topleft",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
#
    # 2. Create survival figure#
    sp.num <- rep(1,length(dff$spcode));#
    for (k in 2:length(sp.list)) sp.num[dff$spcode==sp.list[k]] <- k#
    surv.sp <- dff$surv + 10*sp.num#
    boxplot(dff$size~surv.sp,log="y",axes="FALSE", xlab="Survival status",#
            ylab="DBH (cm)", col=rep(gray.colors(length(sp.list)), each=2))#
    axis(2)#
    axis(1,at=1:6,lab=c(0,1,0,1,0,1))#
    legend("topright",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
#
    #
    # 3. Create corrected growth increment figure#
    incr.corrected <- dff$incr/((dff$exactDatel-dff$exactDate)/365)#
    boxplot(incr.corrected~sp.num, col=gray.colors(length(sp.list)),axes=FALSE,#
            ylab="Time adjusted increment (cm)", ylim=c(-1.5,5))#
    abline(h=0,lty=3)#
    legend("topright",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
    axis(2)#
    axis(1,at=1:3,lab=sp.names)#
    #
    #
    #
#
}#
#
#
#
##note that there are very few species for which sufficient#
## mortality data is actually available! most just don't die...#
##
# vain, myda, hubr#
##
##
fitStatsModelsIndia <- function(species="hubr"){ #
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species=species)#
   #
    dff$size2 <- dff$size^2#
    dff$size3 <- dff$size^3#
    dff$logincr <- log(dff$incr)#
    dff$logincr[!is.finite(dff$logincr)] <- NA#
    #
    tmp.gr <- fitGrowVaryingTimeIntervalsWhiteNoise(dataf=dff,par=c(0.01,0.01,0.01,0.01),#
                                                    cov.names=c("size","size2"))#
    #
    tmp.sv <- fitSurvVaryingTimeIntervals(dataf=dff,par=c(0.01,0.01,0.01),#
                                          #cov.names=c("size","size2"))#
                                          cov.names=c("size","logsize"))#
    gr1 <- tmp.gr$gr1#
    sv1 <- tmp.sv$sv1#
#
    ## PICTURE#
    sizes <- dff$size[!is.na(dff$size)]; sizes <- sizes[order(sizes)]#
    newd <- data.frame(size=sizes,size2=sizes^2, logsize=log(sizes))#
 #
    par(mfrow=c(3,2),bty="l")    #
    plot(dff$size,dff$logincr,pch=19,xlab="size", ylab="log incr", main="Growth")#
    points(newd$size,predict(gr1@fit,newd,type="response"), type="l",col=2)#
#
    p2 <- picSurv(dff,sv1,ncuts=30)  #make this better#
#
    #BUILD Tmatrix#
    Tmatrix <- create.IPM.Tmatrix(nBigMatrix = 300,#
                                  minsize = 0.9*min(dff$size,na.rm=TRUE),#
                                  maxsize = 1.1*max(dff$size,na.rm=TRUE),#
                                  growObj = gr1, survObj = sv1, correction="constant")#
    Tmatrix1 <- create.IPM.Tmatrix(nBigMatrix = 300,#
                                  minsize = 0.9*min(dff$size,na.rm=TRUE),#
                                  maxsize = 1.1*max(dff$size,na.rm=TRUE),#
                                  growObj = gr1, survObj = sv1,integrateType="cumul",#
                                   correction="constant")#
#
    #Persp#
    image(Tmatrix@meshpoints,Tmatrix@meshpoints,Tmatrix)#
    contour(Tmatrix@meshpoints,Tmatrix@meshpoints,Tmatrix, add=TRUE)#
    #
    image(Tmatrix1@meshpoints,Tmatrix1@meshpoints,Tmatrix1)#
    contour(Tmatrix1@meshpoints,Tmatrix1@meshpoints,Tmatrix1, add=TRUE)#
    #
    #
    # Get the mean life expect from every size value in IPM#
    LE <- MeanLifeExpect(Tmatrix)#
    ptime <- PassageTime(chosen.size=1500,Tmatrix); #print(ptime)#
    LE1 <- MeanLifeExpect(Tmatrix1)#
    ptime1 <- PassageTime(chosen.size=1500,Tmatrix1); #print(ptime)#
#
    ## PLOT#
    nyr <- 4#
    plot(Tmatrix@meshpoints,LE*nyr,type="l",xlab="size", ylab="life expectancy",#
         ylim=range(c(LE*nyr,LE1*nyr)))#
    points(Tmatrix1@meshpoints,LE1*nyr,type="l",col=2)#
    plot(Tmatrix@meshpoints,ptime*nyr,type="l",xlab="size", ylab="passage time",#
         ylim=range(c(ptime*nyr,ptime1*nyr)))#
    points(Tmatrix1@meshpoints,ptime1*nyr,type="l",col=2)#
    #
           #
     #
   return(list(resLE=resLE,resPtime=resPtime, sizes=res1$Tmatrix@meshpoints))#
    #
}#
#
#
#
#
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,exp(vals),order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", logLik=",round(vals,1), sep="")),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}#
#
#
#
## Just make a picture of the survival probs from the data#
## [Useful for overlaying various fits...]#
picSurvData <- function(dataf,ncuts=12,...) { #
#
    #organize data and plot mean of ncut successive sizes, so trend more obvious#
    os<-order(dataf$size); os.surv<-(dataf$surv)[os]; os.size<-(dataf$size)[os]; #
    psz<-tapply(os.size,as.numeric(cut(os.size,ncuts)),mean,na.rm=TRUE); #print(psz)#
    ps<-tapply(os.surv,as.numeric(cut(os.size,ncuts)),mean,na.rm=TRUE);#print(ps)#
#
    #plot data#
    plot(as.numeric(psz),as.numeric(ps),pch=19,#
         xlab="Size at t", ylab="Survival to t+1",...)#
    #
}#
#
#
#
## Make Figure 2 - various survival models#
##
FigureTwo <- function(){#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])#
#
#
}#
#
#
## Make Figure 3 - various growth models with data, and then predicted size, sizenext and densty functions#
##
#  NOTE - that this should be using the ADJUSTED increment, hence over-written below by difference sizenext-size#
#  which was obtained via the spline#
##
FigureThree <- function(){#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    for (k in 1:length(chs)) points(rep(sizes[chs[k]],length(sizes)),#
                                    sizes+growth(sizes,sizes[chs[k]],1,res1$gr1), type="l", col=k)#
    #
    #
    return(list(res1=res1,res2=res2,res3=res3))#
}
source("./Documents/workspace/IPMpack/pkg/R/TreesDemog-Base.r")
source("./Documents/workspace/IPMpack/pkg/R/TreesDemog-Impl.r")
source("./Documents/workspace/IPMpack/pkg/R/TreesDemog-Util.r")
#
## This file will containing a suite of different growth functions. For each, there will be#
# 1. a setClass#
# 2. a function predicting size or incr as function size and parameters#
# 3. a likelihood function that can be fed this function and data to optim#
# 3. a growth method for the midpoint rule, and for the cumulative rule#
#
#
# Currently forms are taken from last column in Table 1, Paine et al. MEE, 2011#
#
## THE GOMPERTZ ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Gompertz",#
         representation(paras="numeric",#
                        sd="numeric",#
                        logLik="numeric"))#
#
# Function#
Gompertz <- function(size,paras) {#
    u <- size*paras[1]*log(paras[2]/size)#
    return(u)#
}#
# Pred time course#
Gompertz.overT <- function(size,paras,size0,maxT) {#
    paras[2]*(size0/paras[2])^exp(-paras[1]*(1:maxT))#
}#
#
# Likelihood for optim#
wrapGompertz <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Gompertz(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    #ss <- sum((dataf$incr[!is.na(dataf$incr) & !is.na(dataf$size)]/#
    #           dataf$size[!is.na(dataf$incr) & !is.na(dataf$size)]-#
    #           pred[!is.na(dataf$incr) & !is.na(dataf$size)])^2)#
    #return(ss)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function using max like#
getGompertz <- function(dataf, par=c(8e-4,2.5,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapGompertz, dataf=dataf, method="Nelder-Mead")#
    print(tmp)#
    gr1 <- new("growthObj.Gompertz")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Gompertz(size=dataf$size, paras=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
    return(gr1)#
}#
#
#
# Create wrapper to fit and return a Gompertz growth function using gnls (to allow for heterosc)#
#Gompertz function with named parameters...#
Gompertz2 <- function(X,para1,para2) {#
    para1 <- exp(para1)#
    para2 <- exp(para2)#
    u <- X*para1*log(para2/X)#
    return(u)#
}#
#gnls wrapper#
getGompertz.gnls <- function(dataf,  plot=FALSE) {#
    #prepare data#
    dat.asymp <- data.frame(Y=dataf$incr,X=dataf$size)#
    dat.asymp <- dat.asymp[!is.na(dat.asymp$X) & !is.na(dat.asymp$Y),]#
    dat.asymp <- dat.asymp[dat.asymp$Y>0,]#
    #starting values#
    a1<-getGompertz(dff,plot=T)#
    #fit#
    fit.gomp <- gnls(Y ~ Gompertz2(X, para1,para2),#
                     start=log(c(para1=a1@paras[1],para2=a1@paras[2])),#
                     data = dat.asymp, weights= varExp(form = ~ fitted(.)),#
                     control=gnlsControl(nlsTol=0.1))#
    out.gomp <- output.gomp.gnls(fit.gomp, Xes_asymp$X, CI = T)#
#
    #put this into a growth object#
    #gr1 <- new("growthObj.Gompertz.hetersc")#
    #gr1@paras <- exp(tmp$par[1:2])#
    #gr1@sd <- exp(tmp$par[3])#
    #gr1@logLik <- -tmp$value#
#
}#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Gompertz"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Gompertz"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
## THE FOUR PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic4",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic4 <- function(size,paras) {#
    u <- (paras[1]*(size-paras[3]))*((paras[2]-size)/(paras[2]-paras[3]))#
    return(u)#
}#
#Over t#
Logistic4.overT <- function(size,paras,size0,maxT) {#
    P <- paras[2]-paras[3]-size0#
    u <- paras[3]+size0*((paras[2]-paras[3])/(size0+P*exp(-(paras[1]*(1:maxT)))))#
    return(u)#
}#
#
# Likelihood for optim#
wrapLogistic4 <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Logistic4(dataf$size, paras=par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return #
getLogistic4 <- function(dataf, par=c(0.02,10,0.001,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic4, dataf=dataf, method="Nelder-Mead")  #
    print(tmp)#
     gr1 <- new("growthObj.Logistic4")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
    #
    if(plot) {#
        pred <- Logistic4(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
    return(gr1)#
}#
#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic4"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic4"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
## THE THREE PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic3",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic3 <- function(size,paras) {#
    size*(paras[1]*(1-size/paras[2]))#
}#
# over time#
Logistic3.overT <- function(size,paras,size0,maxT) {#
    size0*paras[2]/(size0+(paras[2]-size0)*exp(-(paras[1]*(1:maxT))))#
}#
#
# Likelihood for optim#
wrapLogistic3 <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Logistic3(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getLogistic3 <- function(dataf, par=c(0.2,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic3, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Logistic3")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Logistic3(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic3"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic3"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
## THE MONOMOLECULAR ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Monomolecular",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Monomolecular <- function(size,paras) {#
    paras[1]*(paras[2]-size)#
}#
#Over t#
Monomolecular.overT <- function(size,paras,size0,maxT) {#
    paras[2]-exp(-(paras[1]*(1:maxT)))*(paras[2]-size0)#
}#
#
# Likelihood for optim#
wrapMonomolecular <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Monomolecular(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getMonomolecular <- function(dataf, par=c(0.002,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapMonomolecular, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Monomolecular")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Monomolecular(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Monomolecular"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Monomolecular"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
###### POWER-LAW #######################################
#
# Create a generic growth object  #
setClass("growthObj.PowerLaw",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
PowerLaw <- function(size,paras) {#
    paras[1]*(size^paras[2])#
}#
#Over t#
PowerLaw.overT <- function(size,paras,size0,maxT) {#
    ((size0^(1-paras[2]))+paras[1]*(1:maxT)*(1-paras[2]))^(1/(1-paras[2]))#
}#
#
#
# Likelihood for optim#
wrapPowerLaw <- function(par, dataf) {#
    par <- exp(par)#
    pred <- PowerLaw(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])
  sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)
dataf<-dff
  sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)
res1
   chs <- c(25,50,75)#
    for (k in 1:length(chs)) points(rep(sizes[chs[k]],length(sizes)),#
                                    sizes+growth(sizes,sizes[chs[k]],1,res1$m1), type="l", col=k)
growth(sizes,sizes[chs[k]],1,res1$m1)
 #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 10#
    for (k in 1:length(chs)) points(rep(sizes[chs[k]],length(sizes)),#
                                    sizes+growth(sizes,sizes[chs[k]],1,res1$m1)*scalar, type="l", col=k)
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 10#
    for (k in 1:length(chs)) points(rep(sizes[chs[k]],length(sizes)),#
                                    sizes[chs[k]]+growth(sizes,sizes[chs[k]],1,res1$m1)*scalar, type="l", col=k)
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 10#
    for (k in 1:length(chs)) points(rep(sizes[chs[k]],length(sizes)),#
                                    sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*1000, type="l", col=k)
  #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 10#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
    #
#
    }
  #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 100#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
    #
#
    }
  #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 1000#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
    #
#
    }
#
    #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 1000#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]+2],length(sizes)),#
               sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]+4],length(sizes)),#
               sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]+6],length(sizes)),#
               sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]+8],length(sizes)),#
               sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
#
    }
#
    #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- c(25,50,75)#
    scalar <- 10000#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]+2],length(sizes)),#
               sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]+4],length(sizes)),#
               sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]+6],length(sizes)),#
               sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]+8],length(sizes)),#
               sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
#
    }
growth(sizes[chs[k]],sizes,1,res1$m5)*scalar
plot(growth(sizes[chs[k]],sizes,1,res1$m5)*scalar)
    #pic just of increments#
    plot(sizes, ylim=c(0,20))#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
 growth(sizes[chs[k]],sizes,1,res1$m5)
#
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, ylim=c(0,20), type="n")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
growth
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,20), type="n")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
#
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,1), type="n")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,0.4), type="n", xlab="Size", ylab="Density in next time-step")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }#
    legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par")
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,0.4), type="n", xlab="Size", ylab="Density in next time-step")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }#
    legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")
    chs <- floor(quantile(1:length(sizes),c(0.25,0.50,0.75)))
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,0.4), type="n", xlab="Size", ylab="Density in next time-step")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }#
    legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")
#
#
    #pic just of increments#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,0.3), type="n", xlab="Size", ylab="Density in next time-step")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }#
    legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")
#
#
    #pic just of increments#
    par(mfrow=c(1,3), bty="l",pty="s")#
    scalar <- 1#
    plot(sizes, sizes, ylim=c(0,0.25), type="n", xlab="Size", ylab="Density in next time-step")#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(sizes,#
               growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }#
    legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")
#
#
    #pic just of increments#
    par(mfrow=c(2,2), bty="l",pty="s")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.25), type="n", xlab="Size", ylab="Density in next time-step")#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")#
    }
#
    #pic just of increments#
    par(mfrow=c(2,2), bty="l",pty="s")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.25), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")#
        mtext(sp.names[j])#
        #
    }
#
    #pic just of increments#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.25), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"), lty=1, col=1:5, bty="n")#
        mtext(sp.names[j])#
        #
    }
  #pic just of increments#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(150,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        #
    }
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(150,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        #
    }
#
#
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(110,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        abline(v=sizes[chs], lty=3)#
        #
    }
#
    #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- floor(quantile(1:length(sizes),c(0.25,0.50,0.75)))#
    scalar <- 1000#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]+2],length(sizes)),#
               sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]+4],length(sizes)),#
               sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]+6],length(sizes)),#
               sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]+8],length(sizes)),#
               sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
#
    #pic size, size next#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    plot(dff$size[dff$spcode==sp.list[1]],dff$sizenext[dff$spcode==sp.list[1]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
    mtext(sp.names[1])#
    chs <- floor(quantile(1:length(sizes),c(0.25,0.50,0.75)))#
    scalar <- 10000#
    for (k in 1:length(chs)) {#
        #Power Law#
        points(rep(sizes[chs[k]],length(sizes)),#
               sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
        #Monomolecular#
        points(rep(sizes[chs[k]+2],length(sizes)),#
               sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
        #Gompertz#
        points(rep(sizes[chs[k]+4],length(sizes)),#
               sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
        #Logistic 3#
        points(rep(sizes[chs[k]+6],length(sizes)),#
               sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
        #Logistic 4#
        points(rep(sizes[chs[k]+8],length(sizes)),#
               sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
#
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        chs <- floor(quantile(1:length(sizes),c(0.25,0.50,0.75)))#
        scalar <- 10000#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(rep(sizes[chs[k]],length(sizes)),#
                   sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(rep(sizes[chs[k]+2],length(sizes)),#
                   sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes)),#
                   sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes)),#
                   sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes)),#
                   sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
#
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        chs <- floor(quantile(1:length(sizes),c(0.25,0.50,0.75)))#
        scalar <- 10000#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(rep(sizes[chs[k]],length(sizes))+#
                   sizes[chs[k]]+growth(sizes[chs[k]],sizes,1,res1$m1)*scalar,sizes, type="l", col=1)#
                                        #Monomolecular#
            points(rep(sizes[chs[k]+2],length(sizes))+#
                   sizes[chs[k]+2]+growth(sizes[chs[k]],sizes,1,res1$m2)*scalar,sizes, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes))+#
                   sizes[chs[k]+4]+growth(sizes[chs[k]],sizes,1,res1$m3)*scalar,sizes, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes))+#
                   sizes[chs[k]+6]+growth(sizes[chs[k]],sizes,1,res1$m4)*scalar,sizes, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes))+#
                   sizes[chs[k]+8]+growth(sizes[chs[k]],sizes,1,res1$m5)*scalar,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        #
    }
  par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 10#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(rep(sizes[chs[k]],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m1)*scalar,sizes, type="l", col=1)#
                                        #Monomolecular#
            points(rep(sizes[chs[k]+2],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m2)*scalar,sizes, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m3)*scalar,sizes, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m4)*scalar,sizes, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m5)*scalar,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        #
    }
 par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(rep(sizes[chs[k]],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m1)*scalar,sizes, type="l", col=1)#
                                        #Monomolecular#
            points(rep(sizes[chs[k]+2],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m2)*scalar,sizes, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m3)*scalar,sizes, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m4)*scalar,sizes, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m5)*scalar,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        #
    }
  par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(rep(sizes[chs[k]],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m1)*scalar,sizes, type="l", col=1)#
                                        #Monomolecular#
            points(rep(sizes[chs[k]+2],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m2)*scalar,sizes, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m3)*scalar,sizes, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m4)*scalar,sizes, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m5)*scalar,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
 #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 1#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
                                        #Power Law#
            points(sizes[chs[k]]+#
                   growth(sizes[chs[k]],sizes,1,res1$m1)*scalar,sizes, type="l", col=1)#
                                        #Monomolecular#
            points(sizes[chs[k]+2]+#
                   growth(sizes[chs[k]],sizes,1,res1$m2)*scalar,sizes, type="l", col=2)#
                                        #Gompertz#
            points(rep(sizes[chs[k]+4],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m3)*scalar,sizes, type="l", col=3)#
                                        #Logistic 3#
            points(rep(sizes[chs[k]+6],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m4)*scalar,sizes, type="l", col=4)#
                                        #Logistic 4#
            points(rep(sizes[chs[k]+8],length(sizes))+#
                   growth(sizes[chs[k]],sizes,1,res1$m5)*scalar,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 1#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)#
                                        #Monomolecular#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
                                        #Gompertz#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)#
                                        #Logistic 3#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
                                        #Logistic 4#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.1#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)#
                                        #Monomolecular#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
                                        #Gompertz#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)#
                                        #Logistic 3#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
                                        #Logistic 4#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)#
                                        #Monomolecular#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
                                        #Gompertz#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)#
                                        #Logistic 3#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
                                        #Logistic 4#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)#
                                        #Monomolecular#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
                                        #Gompertz#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)#
                                        #Logistic 3#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
                                        #Logistic 4#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
makeGrowthObjGeneral
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)#
                                        #Monomolecular#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
                                        #Gompertz#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)#
                                        #Logistic 3#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
                                        #Logistic 4#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("bottomleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
?legend
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    AIC <- -2*length(m0$par)-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
setwd("/Users/jessicametcalf/Documents/workspace/IPMpack/pkg/")
setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")
#setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
source(filename="R/TreesDemog-Util.R")#
source(filename="R/TreesDemog-Base.R")#
source(filename="R/TreesDemog-Impl.R")
source("R/TreesDemog-Impl.R")
source("R/TreesDemog-Util.R")#
source("R/TreesDemog-Base.R")
getwd()
#
#
##### FUNCTIONS USED IN ANALYZING DATA FROM: http://esapubs.org/archive/ecol/E092/115/default.htm#data #
#
#
#setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
#source("R/TreesDemog-Util.R")#
#source("R/TreesDemog-Base.R")#
#source("R/TreesDemog-Impl.R")#
#
#
## Function to alter vector from status description to#
# 0s and 1s#
##
convertStatus <- function(x) {#
    y <- rep(NA,length(x))#
    y[x=="A"] <- 1#
    y[x=="D"] <- 0#
    y[x=="P"] <- 1 #this is a future tree, usuall no size, but prob alives, but these are not evenly sampled#
#
    return(y)#
}#
#
#
## Function to sort out names, create codes, etc#
##  - dumped out now, so don't need to re-run! - #
###
getSp <- function(filename="data/"){#
#
    #write out species names - takes by hand editing so only do once#
    det <-  read.delim(paste(filename,"SpeciesDetails.txt", sep=""),header=TRUE)#
    genus.end <-  regexpr(" ", det[,2]);#
    mat <- cbind(as.character(det$Family), substr(det$LatinName,1,genus.end),#
                 as.character(det$LatinName))#
    write.table(paste(mat[,1],"/",mat[,2],"/",mat[,3], sep=""),#
                file="names.sp",row.names=FALSE, quote = FALSE)#
    #remember, make lower case, put _ between genus and species name, remove " /"#
    #
    #
#
}#
#
#
## Function to pull in all the data taken from#
## http://esapubs.org/archive/ecol/E092/115/default.htm#data#
## Ecological Archives, E092-115-D1.#
## and organize it into a format recognized by IPMpack#
##
# parameters - filename - file describing location of the data#
#            - species - chosen species (four letter code) or "all"#
##
# returns - a data-frame with headings size, sizenext (adjusted for time interval),#
#                incr (raw increment), surv (survival), spcode,#
#              and exactDate and exactDatel in days#
##
getData <- function(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                    species="vain"){#
#
    #bring in the data#
    df <- read.delim(paste(filename,"WesternGhatTrees.txt", sep=""),header=TRUE)#
    if (species!="all") df <- df[df$SpCode==species,]#
#
    #
    #get matrix of dates, sizes, survival #
    dates.raw <- cbind(df$Date0,df$Date1,df$Date2, df$Date3, df$Date4, df$Date5)  #
    sizes.raw <- cbind(df$GBH0,df$GBH1,df$GBH2,df$GBH3,df$GBH4,df$GBH5)#
    surv.raw <- cbind(convertStatus(df$Status0),convertStatus(df$Status1),convertStatus(df$Status2),#
                   convertStatus(df$Status3),convertStatus(df$Status4),convertStatus(df$Status5))#
#
    #get the raw increment for fitting detailed survival model#
    incr <- cbind(df$GBH1-df$GBH0,df$GBH2-df$GBH1,df$GBH3-df$GBH2,df$GBH4-df$GBH3,df$GBH5-df$GBH4)#
    #
    #loop over, predict sizes at days closest to 365*4 (bi-yearly intrvals)#
    pred.dates <- (365*4)*c(0:5)#
    predict.sizes <- matrix(NA,length(df[,1]),length(pred.dates))#
    predict.surv <- matrix(1,length(df[,1]),length(pred.dates))#
        #
    for (k in 1:length(df[,1])) {#
        x <- as.numeric(dates.raw[k,])#
        y <- sizes.raw[k,]#
#
        bad <- is.na(x) | is.na(y)#
        x <- x[!bad]#
        y <- y[!bad]#
     #
        #linear regression#
        if (length(x)<4) { #
            fit <- lm(y~x)#
            predict.sizes[k,] <- predict(fit,newdata=data.frame(x=pred.dates)) #linear reg#
        } else { #
        #smooth spline#
            fit <- smooth.spline(y~x)#
            predict.sizes[k,] <- predict(fit,x=pred.dates)$y #smooth spline#
        }#
            #
        bad <- which(pred.dates>max(x,na.rm=TRUE), arr.ind=TRUE)#
        if (length(bad)>0) predict.sizes[k,bad] <- NA#
        #
        dead <- dates.raw[k,surv.raw[k,]==0][1]#
        loc.dead <- which((dead-pred.dates)^2==min((dead-pred.dates)^2), arr.ind=TRUE)#
        if (length(loc.dead)>0) predict.surv[k,loc.dead:length(pred.dates)] <- 0              #
    }#
#
    #reassure yourself it might work#
#    matplot(t(dates.raw),t(sizes.raw), type="b", pch=19,xlab="dates", ylab="sizes")#
#    abline(v=pred.dates)#
#
        #
    dataf <- data.frame(size=c(predict.sizes[,1:5]),sizenext=c(predict.sizes[,2:6]),#
                        incr=c(incr[,1:5]),#
                        surv=c(predict.surv[,2:6]), spcode=rep(df$SpCode, 5),#
                        exactDate=c(dates.raw[,1:5]), exactDatel=c(dates.raw[,2:6]))#
#
    dataf <- dataf[!is.na(dataf$size),]#
    #
    return(dataf)#
#
}#
#
#
#
#
#
#
## Function to fit survival with varying time increments and then write parameters#
## over onto a classic glm framework. #
##
# parameters - dataf - a dataframe including columns#
#                  size, surv, exactDate, and exactDatel, the latter two in days#
#            - nyrs - desired number of years in a time-step#
#            - par - starting values for the parameters#
#                     (must be of length one longer than cov.names,#
#                       given intercept)#
#            - cov.names - names of chosen covariates#
#            - method - method for optim ("Nelder-Mead", "SANN", etc.)#
##
# Returns  - output of optim#
##
fitSurvVaryingTimeIntervals <- function(dataf,#
                                        nyrs=5,#
                                        par=c(0.01,0.01,0.01,0.01),#
                                        cov.names=c("size","size2","size3"),#
                                        method="Nelder-Mead") {#
#
    #warnings#
    if ((length(par)-1)!=length(cov.names)) {#
        print("starting values does not match length of covariate names")#
    }#
#
    #make sure you have all the right covariates#
    if (length(cov.names)>0) { #
        if (length(grep("size2",cov.names))>0) dataf$size2 <- (dataf$size)^2#
        if (length(grep("size3",cov.names))>0) dataf$size3 <- (dataf$size)^3#
        if (length(grep("logsize",cov.names))>0) dataf$logsize <- log(dataf$size)#
        if (length(grep("logsize2",cov.names))>0) dataf$logsize2 <- (log(dataf$size))^2#
    }#
    #
    tmp <- optim(par,likeSurvVaryingTimeIntervals,#
                 cov.names=cov.names,nyrs=nyrs,dataf=dataf,#
                 method=method)#
#
    #
    if (tmp$convergence!=0) {#
        tmp <- optim(tmp$par,likeSurvVaryingTimeIntervals,#
                     cov.names=cov.names,nyrs=nyrs,dataf=dataf,#
                     method=method)#
        if (tmp$convergence!=0)  print("not converged")        #
    }#
    #
    #write template over the top#
    if (length(cov.names)>0) formula <- as.character(paste("surv~",paste(cov.names,collapse="+"),collapse="")) else formula <- as.character("surv~1")#
    fit <- glm(formula,data=dataf,family=binomial)#
    #print(fit)#
    fit$coefficients <- tmp$par#
#
    sv1 <- new("survObj")#
    sv1@fit <- fit#
#
    tmp$sv1 <- sv1#
    #
#
    return(tmp)#
#return(list(tmp=tmp,sv1=sv1))#
#
}#
#
#Function to calculate the likelihood for variable time-intervals for survival #
##
# parameters #
#            - par - starting values for the parameters#
#                     (must be of length one longer than cov.names,#
#                       given intercept)#
#            - cov.names - names of chosen covariates#
#            - nyrs - desired number of years in a time-step#
#            - dataf - a dataframe including columns in cov.names, as well as#
#                  size, surv, exactDate, and exactDatel, the latter two in days#
##
# Returns  - numeric equal to minus the log likelihood#
##
likeSurvVaryingTimeIntervals <- function(par=c(0.01,0.01,0.01,0.01),#
                                         cov.names=c("size","size2","size3"),#
                                         nyrs=5,#
                                         dataf) {#
#
    #
    #define time change#
    tdiff <- (dataf$exactDatel-dataf$exactDate)/(nyrs*365)#
    #print(range(tdiff, na.rm=TRUE))#
#
    #build predictor#
    if (length(cov.names)>0) {#
        pred <-  t(t(dataf[,cov.names])*par[2:length(par)])#
    }else { pred <- matrix(0,nrow(dataf),1)}#
    pred <- par[1] + rowSums(pred)#
    pred[pred>200] <- 200  #don't want bigger than exp(200) - gets infinite really quick#
    pred <- (exp(pred)/(1+exp(pred)))^(tdiff)#
    #
    #estimate likelihood#
    like <- dbinom(dataf$surv,1,pred, log=TRUE)#
    #like[like==-Inf] <- -exp(500)#
    #like[like==Inf] <- exp(500)#
#
    sumRows <- rep(0,nrow(dataf))#
    if (length(cov.names)>1) sumRows <- rowSums(dataf[,cov.names])#
    if (length(cov.names)==1) sumRows <- dataf[,cov.names]#
    #
    return(-sum(like[!is.na(sumRows) & !is.na(dataf$surv)],na.rm=TRUE))#
    #
}#
#
#
## Make Figure 1- showning basic qualities of the data ####
## for three species with sufficient mortality info ######
##
FigureOne <- function(){#
#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    #
    # 1. create exact times figure#
    par(mfrow=c(1,3),bty="l")#
    brks <- c(-0.5,1.5,2.5,3.5,4.5,5.5)#
    #
    for (k in 1:length(sp.list)) {#
        a1<-hist(c(dff$exactDatel[dff$spcode==sp.list[k]]-dff$exactDate[dff$spcode==sp.list[k]])/365,#
        breaks=brks, plot=FALSE)#
        if (k==1) cts <- a1$counts#
        if (k>1) cts <- rbind(cts,a1$counts)#
    #
    }#
#
    barplot(cts,beside=TRUE, names.arg=c("<1","2","3","4","5"), xlab="Census interval (years)")#
    legend("topleft",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
#
    # 2. Create survival figure#
    sp.num <- rep(1,length(dff$spcode));#
    for (k in 2:length(sp.list)) sp.num[dff$spcode==sp.list[k]] <- k#
    surv.sp <- dff$surv + 10*sp.num#
    boxplot(dff$size~surv.sp,log="y",axes="FALSE", xlab="Survival status",#
            ylab="DBH (cm)", col=rep(gray.colors(length(sp.list)), each=2))#
    axis(2)#
    axis(1,at=1:6,lab=c(0,1,0,1,0,1))#
    legend("topright",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
#
    #
    # 3. Create corrected growth increment figure#
    incr.corrected <- dff$incr/((dff$exactDatel-dff$exactDate)/365)#
    boxplot(incr.corrected~sp.num, col=gray.colors(length(sp.list)),axes=FALSE,#
            ylab="Time adjusted increment (cm)", ylim=c(-1.5,5))#
    abline(h=0,lty=3)#
    legend("topright",legend=sp.names,col=gray.colors(length(sp.list)), pch=15, bty="n")#
    axis(2)#
    axis(1,at=1:3,lab=sp.names)#
    #
    #
    #
#
}#
#
#
#
##note that there are very few species for which sufficient#
## mortality data is actually available! most just don't die...#
##
# vain, myda, hubr#
##
##
fitStatsModelsIndia <- function(species="hubr"){ #
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species=species)#
   #
    dff$size2 <- dff$size^2#
    dff$size3 <- dff$size^3#
    dff$logincr <- log(dff$incr)#
    dff$logincr[!is.finite(dff$logincr)] <- NA#
    #
    tmp.gr <- fitGrowVaryingTimeIntervalsWhiteNoise(dataf=dff,par=c(0.01,0.01,0.01,0.01),#
                                                    cov.names=c("size","size2"))#
    #
    tmp.sv <- fitSurvVaryingTimeIntervals(dataf=dff,par=c(0.01,0.01,0.01),#
                                          #cov.names=c("size","size2"))#
                                          cov.names=c("size","logsize"))#
    gr1 <- tmp.gr$gr1#
    sv1 <- tmp.sv$sv1#
#
    ## PICTURE#
    sizes <- dff$size[!is.na(dff$size)]; sizes <- sizes[order(sizes)]#
    newd <- data.frame(size=sizes,size2=sizes^2, logsize=log(sizes))#
 #
    par(mfrow=c(3,2),bty="l")    #
    plot(dff$size,dff$logincr,pch=19,xlab="size", ylab="log incr", main="Growth")#
    points(newd$size,predict(gr1@fit,newd,type="response"), type="l",col=2)#
#
    p2 <- picSurv(dff,sv1,ncuts=30)  #make this better#
#
    #BUILD Tmatrix#
    Tmatrix <- create.IPM.Tmatrix(nBigMatrix = 300,#
                                  minsize = 0.9*min(dff$size,na.rm=TRUE),#
                                  maxsize = 1.1*max(dff$size,na.rm=TRUE),#
                                  growObj = gr1, survObj = sv1, correction="constant")#
    Tmatrix1 <- create.IPM.Tmatrix(nBigMatrix = 300,#
                                  minsize = 0.9*min(dff$size,na.rm=TRUE),#
                                  maxsize = 1.1*max(dff$size,na.rm=TRUE),#
                                  growObj = gr1, survObj = sv1,integrateType="cumul",#
                                   correction="constant")#
#
    #Persp#
    image(Tmatrix@meshpoints,Tmatrix@meshpoints,Tmatrix)#
    contour(Tmatrix@meshpoints,Tmatrix@meshpoints,Tmatrix, add=TRUE)#
    #
    image(Tmatrix1@meshpoints,Tmatrix1@meshpoints,Tmatrix1)#
    contour(Tmatrix1@meshpoints,Tmatrix1@meshpoints,Tmatrix1, add=TRUE)#
    #
    #
    # Get the mean life expect from every size value in IPM#
    LE <- MeanLifeExpect(Tmatrix)#
    ptime <- PassageTime(chosen.size=1500,Tmatrix); #print(ptime)#
    LE1 <- MeanLifeExpect(Tmatrix1)#
    ptime1 <- PassageTime(chosen.size=1500,Tmatrix1); #print(ptime)#
#
    ## PLOT#
    nyr <- 4#
    plot(Tmatrix@meshpoints,LE*nyr,type="l",xlab="size", ylab="life expectancy",#
         ylim=range(c(LE*nyr,LE1*nyr)))#
    points(Tmatrix1@meshpoints,LE1*nyr,type="l",col=2)#
    plot(Tmatrix@meshpoints,ptime*nyr,type="l",xlab="size", ylab="passage time",#
         ylim=range(c(ptime*nyr,ptime1*nyr)))#
    points(Tmatrix1@meshpoints,ptime1*nyr,type="l",col=2)#
    #
           #
     #
   return(list(resLE=resLE,resPtime=resPtime, sizes=res1$Tmatrix@meshpoints))#
    #
}#
#
#
#
#
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    AIC <- -2*length(m0$par)-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}#
#
#
#
## Just make a picture of the survival probs from the data#
## [Useful for overlaying various fits...]#
picSurvData <- function(dataf,ncuts=12,...) { #
#
    #organize data and plot mean of ncut successive sizes, so trend more obvious#
    os<-order(dataf$size); os.surv<-(dataf$surv)[os]; os.size<-(dataf$size)[os]; #
    psz<-tapply(os.size,as.numeric(cut(os.size,ncuts)),mean,na.rm=TRUE); #print(psz)#
    ps<-tapply(os.surv,as.numeric(cut(os.size,ncuts)),mean,na.rm=TRUE);#print(ps)#
#
    #plot data#
    plot(as.numeric(psz),as.numeric(ps),pch=19,#
         xlab="Size at t", ylab="Survival to t+1",...)#
    #
}#
#
#
#
## Make Figure 2 - various survival models#
##
FigureTwo <- function(){#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])#
#
#
}#
#
#
## Make Figure 3 - various growth models with data, and then predicted size, sizenext and densty functions#
##
#  NOTE - that this should be using the ADJUSTED increment, hence over-written below by difference sizenext-size#
#  which was obtained via the spline#
##
FigureThree <- function(){#
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }#
#
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(110,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        abline(v=sizes[chs], lty=3)#
        #
    }#
#
#
#
    #
    return(list(res1=res1,res2=res2,res3=res3))#
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    AIC <- 2*length(m0$par)-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    AIC <- 2*c(length(m$par),length(m0$par),length(m1$par),length(m2$par)length(m0a$par),length(m1a$par),length(m2a$par))-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
#
## Function to fit survival models and compare liklelihoods#
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(-2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(-2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(-2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(-2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(-2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(-2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value)#
    AIC <- 2*c(length(m$par),length(m0$par),length(m1$par),length(m2$par),length(m0a$par),length(m1a$par),length(m2a$par))-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
#
likeCompSurvVaryInterval <- function(dataf, plot=FALSE) {#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=0.01,cov.names=c())#
    m0 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(0.01,0.01),cov.names=c("size"))#
    m1 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","size2"))#
    m2 <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1$par,0),cov.names=c("size","size2","size3"))#
    #
    print("Comparison intercept and size")#
    print(1-pchisq(2*(m$value-m0$value),1))#
    print("Comparison size and size2")#
    print(1-pchisq(2*(m0$value-m1$value),1))#
    print("Comparison size2 and size3")#
    print(1-pchisq(2*(m1$value-m2$value),1))#
#
    m0a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par),cov.names=c("logsize"))#
    m1a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m0$par,0),cov.names=c("size","logsize"))#
    m2a <- fitSurvVaryingTimeIntervals(dataf,nyrs=4,par=c(m1a$par,0),cov.names=c("size","logsize","logsize2"))#
#
    print("Comparison intercept and logsize")#
    print(1-pchisq(2*(m$value-m0a$value),1))#
    print("Comparison logsize and size+logsize")#
    print(1-pchisq(2*(m0a$value-m1a$value),1))#
    print("Comparison logsize and logsize2")#
    print(1-pchisq(2*(m1a$value-m2a$value),1))#
#
    print("Direct comparison likelihoods")#
    vals <- -c(m$value,m0$value,m1$value,m2$value,m0a$value,m1a$val,m2a$value) #log likelihood#
    AIC <- 2*c(length(m$par),length(m0$par),length(m1$par),length(m2$par),length(m0a$par),length(m1a$par),length(m2a$par))-2*vals#
    nmes <- c("1","size","size+size2","size+size2+size3","logsize","size+logsize","size+logsize+logsize2")#
    print(cbind(nmes,vals,AIC,order(vals)))#
    #
#
    if (plot) {#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        picSurvData(dataf,ncuts=20)#
        points(sizes,surv(sizes,1,m$sv1),type="l",col=4, lty=2)#
        points(sizes,surv(sizes,1,m0$sv1),type="l",col=1, lty=2)#
        points(sizes,surv(sizes,1,m1$sv1),type="l",col=2, lty=2)#
        points(sizes,surv(sizes,1,m2$sv1),type="l",col=3, lty=2)#
        points(sizes,surv(sizes,1,m0a$sv1),type="l",col=1, lty=3)#
        points(sizes,surv(sizes,1,m1a$sv1),type="l",col=2, lty=3)#
        points(sizes,surv(sizes,1,m2a$sv1),type="l",col=3, lty=3)#
        legend("bottomleft", legend=paste(nmes,paste(", AIC=",round(AIC,1), sep="")), text.col=c(4,1:3,1:3),#
               col=c(4,1:3,1:3),lty=c(2,rep(2,3),rep(3,3)), bty="o", cex=0.8,bg="white",box.col="white")#
     #
    }#
                 #
}
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
#
    par(mfrow=c(1,3),bty="l",family = "Helvetica")#
    #
    res1 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE)#
    title(sp.names[1])#
    res2 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    title(sp.names[2])#
    res3 <- likeCompSurvVaryInterval(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    title(sp.names[3])
?lm
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }#
#
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(110,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        abline(v=sizes[chs], lty=3)#
        #
    }
  sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)
dataf<-dff
  sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)
#
    sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }#
#
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35), type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3#
            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            #
        }#
        if (j==1) legend(110,0.35, legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        abline(v=sizes[chs], lty=3)#
        #
    }
  sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
## This file will containing a suite of different growth functions. For each, there will be#
# 1. a setClass#
# 2. a function predicting size or incr as function size and parameters#
# 3. a likelihood function that can be fed this function and data to optim#
# 3. a growth method for the midpoint rule, and for the cumulative rule#
#
#
# Currently forms are taken from last column in Table 1, Paine et al. MEE, 2011#
#
## THE GOMPERTZ ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Gompertz",#
         representation(paras="numeric",#
                        sd="numeric",#
                        logLik="numeric"))#
#
# Function#
Gompertz <- function(size,paras) {#
    u <- size*paras[1]*log(paras[2]/size)#
    return(u)#
}#
# Pred time course#
Gompertz.overT <- function(size,paras,size0,maxT) {#
    paras[2]*(size0/paras[2])^exp(-paras[1]*(1:maxT))#
}#
#
# Likelihood for optim#
wrapGompertz <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Gompertz(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    #ss <- sum((dataf$incr[!is.na(dataf$incr) & !is.na(dataf$size)]/#
    #           dataf$size[!is.na(dataf$incr) & !is.na(dataf$size)]-#
    #           pred[!is.na(dataf$incr) & !is.na(dataf$size)])^2)#
    #return(ss)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function using max like#
getGompertz <- function(dataf, par=c(8e-4,2.5,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapGompertz, dataf=dataf, method="Nelder-Mead")#
    print(tmp)#
    gr1 <- new("growthObj.Gompertz")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Gompertz(size=dataf$size, paras=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
    return(gr1)#
}#
#
#
# Create wrapper to fit and return a Gompertz growth function using gnls (to allow for heterosc)#
#Gompertz function with named parameters...#
Gompertz2 <- function(X,para1,para2) {#
    para1 <- exp(para1)#
    para2 <- exp(para2)#
    u <- X*para1*log(para2/X)#
    return(u)#
}#
#gnls wrapper#
getGompertz.gnls <- function(dataf,  plot=FALSE) {#
    #prepare data#
    dat.asymp <- data.frame(Y=dataf$incr,X=dataf$size)#
    dat.asymp <- dat.asymp[!is.na(dat.asymp$X) & !is.na(dat.asymp$Y),]#
    dat.asymp <- dat.asymp[dat.asymp$Y>0,]#
    #starting values#
    a1<-getGompertz(dff,plot=T)#
    #fit#
    fit.gomp <- gnls(Y ~ Gompertz2(X, para1,para2),#
                     start=log(c(para1=a1@paras[1],para2=a1@paras[2])),#
                     data = dat.asymp, weights= varExp(form = ~ fitted(.)),#
                     control=gnlsControl(nlsTol=0.1))#
    out.gomp <- output.gomp.gnls(fit.gomp, Xes_asymp$X, CI = T)#
#
    #put this into a growth object#
    #gr1 <- new("growthObj.Gompertz.hetersc")#
    #gr1@paras <- exp(tmp$par[1:2])#
    #gr1@sd <- exp(tmp$par[3])#
    #gr1@logLik <- -tmp$value#
#
}#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Gompertz"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Gompertz"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
## THE FOUR PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic4",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic4 <- function(size,paras) {#
    u <- (paras[1]*(size-paras[3]))*((paras[2]-size)/(paras[2]-paras[3]))#
    return(u)#
}#
#Over t#
Logistic4.overT <- function(size,paras,size0,maxT) {#
    P <- paras[2]-paras[3]-size0#
    u <- paras[3]+size0*((paras[2]-paras[3])/(size0+P*exp(-(paras[1]*(1:maxT)))))#
    return(u)#
}#
#
# Likelihood for optim#
wrapLogistic4 <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Logistic4(dataf$size, paras=par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return #
getLogistic4 <- function(dataf, par=c(0.02,10,0.001,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic4, dataf=dataf, method="Nelder-Mead")  #
    print(tmp)#
     gr1 <- new("growthObj.Logistic4")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
    #
    if(plot) {#
        pred <- Logistic4(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
    return(gr1)#
}#
#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic4"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic4"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
## THE THREE PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic3",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic3 <- function(size,paras) {#
    size*(paras[1]*(1-size/paras[2]))#
}#
# over time#
Logistic3.overT <- function(size,paras,size0,maxT) {#
    size0*paras[2]/(size0+(paras[2]-size0)*exp(-(paras[1]*(1:maxT))))#
}#
#
# Likelihood for optim#
wrapLogistic3 <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Logistic3(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getLogistic3 <- function(dataf, par=c(0.2,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic3, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Logistic3")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Logistic3(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic3"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic3"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
## THE MONOMOLECULAR ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Monomolecular",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Monomolecular <- function(size,paras) {#
    paras[1]*(paras[2]-size)#
}#
#Over t#
Monomolecular.overT <- function(size,paras,size0,maxT) {#
    paras[2]-exp(-(paras[1]*(1:maxT)))*(paras[2]-size0)#
}#
#
# Likelihood for optim#
wrapMonomolecular <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Monomolecular(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getMonomolecular <- function(dataf, par=c(0.002,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapMonomolecular, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Monomolecular")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Monomolecular(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Monomolecular"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Monomolecular"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
###### POWER-LAW #######################################
#
# Create a generic growth object  #
setClass("growthObj.PowerLaw",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
PowerLaw <- function(size,paras) {#
    paras[1]*(size^paras[2])#
}#
#Over t#
PowerLaw.overT <- function(size,paras,size0,maxT) {#
    ((size0^(1-paras[2]))+paras[1]*(1:maxT)*(1-paras[2]))^(1/(1-paras[2]))#
}#
#
#
# Likelihood for optim#
wrapPowerLaw <- function(par, dataf) {#
    par <- exp(par)#
    pred <- PowerLaw(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
  sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par"),#
            lty=1, col=1:5, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
 dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")
table(dff$species,dff$surv)
table(dff$specie,dff$surv)
table(dff$spcode,dff$surv)
 gr1 <- new("growthObj.Hossfeld")
gr1
Hossfeld
#
## This file will containing a suite of different growth functions. For each, there will be#
# 1. a setClass#
# 2. a function predicting size or incr as function size and parameters#
# 3. a likelihood function that can be fed this function and data to optim#
# 3. a growth method for the midpoint rule, and for the cumulative rule#
#
#
# Currently forms are taken from last column in Table 1, Paine et al. MEE, 2011#
#
## THE GOMPERTZ ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Gompertz",#
         representation(paras="numeric",#
                        sd="numeric",#
                        logLik="numeric"))#
#
# Function#
Gompertz <- function(size,paras) {#
    u <- size*paras[1]*log(paras[2]/size)#
    return(u)#
}#
# Pred time course#
Gompertz.overT <- function(size,paras,size0,maxT) {#
    paras[2]*(size0/paras[2])^exp(-paras[1]*(1:maxT))#
}#
#
# Likelihood for optim#
wrapGompertz <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Gompertz(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    #ss <- sum((dataf$incr[!is.na(dataf$incr) & !is.na(dataf$size)]/#
    #           dataf$size[!is.na(dataf$incr) & !is.na(dataf$size)]-#
    #           pred[!is.na(dataf$incr) & !is.na(dataf$size)])^2)#
    #return(ss)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function using max like#
getGompertz <- function(dataf, par=c(8e-4,2.5,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapGompertz, dataf=dataf, method="Nelder-Mead")#
    print(tmp)#
    gr1 <- new("growthObj.Gompertz")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Gompertz(size=dataf$size, paras=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
    return(gr1)#
}#
#
#
# Create wrapper to fit and return a Gompertz growth function using gnls (to allow for heterosc)#
#Gompertz function with named parameters...#
Gompertz2 <- function(X,para1,para2) {#
    para1 <- exp(para1)#
    para2 <- exp(para2)#
    u <- X*para1*log(para2/X)#
    return(u)#
}#
#gnls wrapper#
getGompertz.gnls <- function(dataf,  plot=FALSE) {#
    #prepare data#
    dat.asymp <- data.frame(Y=dataf$incr,X=dataf$size)#
    dat.asymp <- dat.asymp[!is.na(dat.asymp$X) & !is.na(dat.asymp$Y),]#
    dat.asymp <- dat.asymp[dat.asymp$Y>0,]#
    #starting values#
    a1<-getGompertz(dff,plot=T)#
    #fit#
    fit.gomp <- gnls(Y ~ Gompertz2(X, para1,para2),#
                     start=log(c(para1=a1@paras[1],para2=a1@paras[2])),#
                     data = dat.asymp, weights= varExp(form = ~ fitted(.)),#
                     control=gnlsControl(nlsTol=0.1))#
    out.gomp <- output.gomp.gnls(fit.gomp, Xes_asymp$X, CI = T)#
#
    #put this into a growth object#
    #gr1 <- new("growthObj.Gompertz.hetersc")#
    #gr1@paras <- exp(tmp$par[1:2])#
    #gr1@sd <- exp(tmp$par[3])#
    #gr1@logLik <- -tmp$value#
#
}#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Gompertz"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Gompertz"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
## THE FOUR PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic4",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic4 <- function(size,paras) {#
    u <- (paras[1]*(size-paras[3]))*((paras[2]-size)/(paras[2]-paras[3]))#
    return(u)#
}#
#Over t#
Logistic4.overT <- function(size,paras,size0,maxT) {#
    P <- paras[2]-paras[3]-size0#
    u <- paras[3]+size0*((paras[2]-paras[3])/(size0+P*exp(-(paras[1]*(1:maxT)))))#
    return(u)#
}#
#
# Likelihood for optim#
wrapLogistic4 <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Logistic4(dataf$size, paras=par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return #
getLogistic4 <- function(dataf, par=c(0.02,10,0.001,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic4, dataf=dataf, method="Nelder-Mead")  #
    print(tmp)#
     gr1 <- new("growthObj.Logistic4")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
    #
    if(plot) {#
        pred <- Logistic4(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
    return(gr1)#
}#
#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic4"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic4"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
## THE THREE PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic3",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic3 <- function(size,paras) {#
    size*(paras[1]*(1-size/paras[2]))#
}#
# over time#
Logistic3.overT <- function(size,paras,size0,maxT) {#
    size0*paras[2]/(size0+(paras[2]-size0)*exp(-(paras[1]*(1:maxT))))#
}#
#
# Likelihood for optim#
wrapLogistic3 <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Logistic3(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getLogistic3 <- function(dataf, par=c(0.2,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic3, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Logistic3")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Logistic3(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic3"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic3"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
## THE MONOMOLECULAR ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Monomolecular",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Monomolecular <- function(size,paras) {#
    paras[1]*(paras[2]-size)#
}#
#Over t#
Monomolecular.overT <- function(size,paras,size0,maxT) {#
    paras[2]-exp(-(paras[1]*(1:maxT)))*(paras[2]-size0)#
}#
#
# Likelihood for optim#
wrapMonomolecular <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Monomolecular(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getMonomolecular <- function(dataf, par=c(0.002,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapMonomolecular, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Monomolecular")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Monomolecular(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Monomolecular"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Monomolecular"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
###### POWER-LAW #######################################
#
# Create a generic growth object  #
setClass("growthObj.PowerLaw",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
PowerLaw <- function(size,paras) {#
    paras[1]*(size^paras[2])#
}#
#Over t#
PowerLaw.overT <- function(size,paras,size0,maxT) {#
    ((size0^(1-paras[2]))+paras[1]*(1:maxT)*(1-paras[2]))^(1/(1-paras[2]))#
}#
#
#
# Likelihood for optim#
wrapPowerLaw <- function(par, dataf) {#
    par <- exp(par)#
    pred <- PowerLaw(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
###### HOSSFELD #######################################
#
#slightly different from one in main, since also getting variance + doing parameters on log scale#
wrapHossfeld. <- function(par, dataf) { #
    par <- exp(par)#
    pred <- Hossfeld(dataf$size, par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
 } #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getHossfeld <- function(dataf, par=c(0.002,0.01,1,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapHossfeld., dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Hossfeld")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Hossfeld(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
#
#
#
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),#
                                        quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    m6 <-  getHossfeld(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Hossfeld")#
    legend("bottomleft",legend=paste("logLik=",round(m6@logLik,1)),bty="n", cex=0.8)#
#
    #
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5))#
    #
}
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),#
                                        quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    m6 <-  getHossfeld(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Hossfeld")#
    legend("bottomleft",legend=paste("logLik=",round(m6@logLik,1)),bty="n", cex=0.8)#
#
    #
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5, m6=m6))#
    #
}
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),#
                                        quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    m6 <-  getHossfeld(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Hossfeld")#
    legend("bottomleft",legend=paste("logLik=",round(m6@logLik,1)),bty="n", cex=0.8)#
#
    #
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5, m6=m6))#
    #
}
 sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001
#setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
source(filename="R/TreesDemog-Util.R")#
source(filename="R/TreesDemog-Base.R")#
source(filename="R/TreesDemog-Impl.R")
setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
source(filename="R/TreesDemog-Util.R")#
source(filename="R/TreesDemog-Base.R")#
source(filename="R/TreesDemog-Impl.R")
setwd("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/")#
source("R/TreesDemog-Util.R")#
source("R/TreesDemog-Base.R")#
source("R/TreesDemog-Impl.R")
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),#
                                        quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    m6 <-  getHossfeld(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Hossfeld")#
    legend("bottomleft",legend=paste("logLik=",round(m6@logLik,1)),bty="n", cex=0.8)#
#
    #
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5, m6=m6))#
    #
}
 sp.list <- c("vain", "myda", "hubr")#
    sp.names <- c("Vateria indica", "Myristica dactyloides", "Humboldtia brunonis")#
#
    dff <- getData(filename="/Users/cjessicametcalf/Documents/IPM/data/",#
                   species="all")#
    dff <- dff[dff$spcode==sp.list[1] | dff$spcode==sp.list[2] | dff$spcode==sp.list[3],]#
    dff$incr <- dff$sizenext - dff$size#
    #
    #pic with the data#
    par(mfrow=c(3,5),bty="l", pty="m")#
    res1 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[1],], plot=TRUE, plot.title=TRUE)#
    mtext(sp.names[1])#
    res2 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[2],], plot=TRUE)#
    mtext(sp.names[2])#
    res3 <- likeCompGrowthMech(dataf=dff[dff$spcode==sp.list[3],], plot=TRUE)#
    mtext(sp.names[3])#
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]+9+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]+9]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]+9]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
## This file will containing a suite of different growth functions. For each, there will be#
# 1. a setClass#
# 2. a function predicting size or incr as function size and parameters#
# 3. a likelihood function that can be fed this function and data to optim#
# 3. a growth method for the midpoint rule, and for the cumulative rule#
#
#
# Currently forms are taken from last column in Table 1, Paine et al. MEE, 2011#
#
## THE GOMPERTZ ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Gompertz",#
         representation(paras="numeric",#
                        sd="numeric",#
                        logLik="numeric"))#
#
# Function#
Gompertz <- function(size,paras) {#
    u <- size*paras[1]*log(paras[2]/size)#
    return(u)#
}#
# Pred time course#
Gompertz.overT <- function(size,paras,size0,maxT) {#
    paras[2]*(size0/paras[2])^exp(-paras[1]*(1:maxT))#
}#
#
# Likelihood for optim#
wrapGompertz <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Gompertz(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    #ss <- sum((dataf$incr[!is.na(dataf$incr) & !is.na(dataf$size)]/#
    #           dataf$size[!is.na(dataf$incr) & !is.na(dataf$size)]-#
    #           pred[!is.na(dataf$incr) & !is.na(dataf$size)])^2)#
    #return(ss)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function using max like#
getGompertz <- function(dataf, par=c(8e-4,2.5,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapGompertz, dataf=dataf, method="Nelder-Mead")#
    print(tmp)#
    gr1 <- new("growthObj.Gompertz")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Gompertz(size=dataf$size, paras=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
    return(gr1)#
}#
#
#
# Create wrapper to fit and return a Gompertz growth function using gnls (to allow for heterosc)#
#Gompertz function with named parameters...#
Gompertz2 <- function(X,para1,para2) {#
    para1 <- exp(para1)#
    para2 <- exp(para2)#
    u <- X*para1*log(para2/X)#
    return(u)#
}#
#gnls wrapper#
getGompertz.gnls <- function(dataf,  plot=FALSE) {#
    #prepare data#
    dat.asymp <- data.frame(Y=dataf$incr,X=dataf$size)#
    dat.asymp <- dat.asymp[!is.na(dat.asymp$X) & !is.na(dat.asymp$Y),]#
    dat.asymp <- dat.asymp[dat.asymp$Y>0,]#
    #starting values#
    a1<-getGompertz(dff,plot=T)#
    #fit#
    fit.gomp <- gnls(Y ~ Gompertz2(X, para1,para2),#
                     start=log(c(para1=a1@paras[1],para2=a1@paras[2])),#
                     data = dat.asymp, weights= varExp(form = ~ fitted(.)),#
                     control=gnlsControl(nlsTol=0.1))#
    out.gomp <- output.gomp.gnls(fit.gomp, Xes_asymp$X, CI = T)#
#
    #put this into a growth object#
    #gr1 <- new("growthObj.Gompertz.hetersc")#
    #gr1@paras <- exp(tmp$par[1:2])#
    #gr1@sd <- exp(tmp$par[3])#
    #gr1@logLik <- -tmp$value#
#
}#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Gompertz"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Gompertz"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Gompertz(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
## THE FOUR PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic4",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic4 <- function(size,paras) {#
    u <- (paras[1]*(size-paras[3]))*((paras[2]-size)/(paras[2]-paras[3]))#
    return(u)#
}#
#Over t#
Logistic4.overT <- function(size,paras,size0,maxT) {#
    P <- paras[2]-paras[3]-size0#
    u <- paras[3]+size0*((paras[2]-paras[3])/(size0+P*exp(-(paras[1]*(1:maxT)))))#
    return(u)#
}#
#
# Likelihood for optim#
wrapLogistic4 <- function(par, dataf) {#
    par <- exp(par) #they all need to be positive#
    pred <- Logistic4(dataf$size, paras=par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return #
getLogistic4 <- function(dataf, par=c(0.02,10,0.001,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic4, dataf=dataf, method="Nelder-Mead")  #
    print(tmp)#
     gr1 <- new("growthObj.Logistic4")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
    #
    if(plot) {#
        pred <- Logistic4(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
    return(gr1)#
}#
#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic4"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic4"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic4(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
## THE THREE PARAMETER LOGISTIC ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Logistic3",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Logistic3 <- function(size,paras) {#
    size*(paras[1]*(1-size/paras[2]))#
}#
# over time#
Logistic3.overT <- function(size,paras,size0,maxT) {#
    size0*paras[2]/(size0+(paras[2]-size0)*exp(-(paras[1]*(1:maxT))))#
}#
#
# Likelihood for optim#
wrapLogistic3 <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Logistic3(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getLogistic3 <- function(dataf, par=c(0.2,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapLogistic3, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Logistic3")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Logistic3(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
#
#
#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Logistic3"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Logistic3"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Logistic3(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
#
#
#
## THE MONOMOLECULAR ##################################################################
#
#
# Create a generic growth object  #
setClass("growthObj.Monomolecular",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
Monomolecular <- function(size,paras) {#
    paras[1]*(paras[2]-size)#
}#
#Over t#
Monomolecular.overT <- function(size,paras,size0,maxT) {#
    paras[2]-exp(-(paras[1]*(1:maxT)))*(paras[2]-size0)#
}#
#
# Likelihood for optim#
wrapMonomolecular <- function(par, dataf) {#
    par <- exp(par)#
    pred <- Monomolecular(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getMonomolecular <- function(dataf, par=c(0.002,77,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapMonomolecular, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Monomolecular")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Monomolecular(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.Monomolecular"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.Monomolecular"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+Monomolecular(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
#
#
###### POWER-LAW #######################################
#
# Create a generic growth object  #
setClass("growthObj.PowerLaw",#
         representation(paras="numeric",#
                        sd="numeric",logLik="numeric"))#
#
# Function#
PowerLaw <- function(size,paras) {#
    paras[1]*(size^paras[2])#
}#
#Over t#
PowerLaw.overT <- function(size,paras,size0,maxT) {#
    ((size0^(1-paras[2]))+paras[1]*(1:maxT)*(1-paras[2]))^(1/(1-paras[2]))#
}#
#
#
# Likelihood for optim#
wrapPowerLaw <- function(par, dataf) {#
    par <- exp(par)#
    pred <- PowerLaw(size=dataf$size, paras=par[1:2]) #
    logLik <- dnorm(dataf$incr,pred,par[3], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
} #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getPowerLaw <- function(dataf, par=c(0.002,0.01,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapPowerLaw, dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.PowerLaw")#
    gr1@paras <- exp(tmp$par[1:2])#
    gr1@sd <- exp(tmp$par[3])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- PowerLaw(size=dataf$size,par=exp(tmp$par[1:2])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
# Define a new growth method (classic midpoint rule approach)#
setMethod("growth", c("numeric", "numeric", "numeric", "growthObj.PowerLaw"), #
          function(size, sizenext, cov, growthObj) { #
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <- growthObj@sd #
              u <- dnorm(sizenext, mux, sigmax, log = F) #
              return(u)#
          })#
#
#
# Define a new growth method (cumulative  approach)#
setMethod("growthCum", #
          c("numeric","numeric","numeric","growthObj.PowerLaw"),#
          function(size,sizenext,cov,growthObj){#
              mux <- size+PowerLaw(size=size, paras=growthObj@paras) #
              sigmax <-  growthObj@sd#
              u <- pnorm(sizenext,mux,sigmax,log=FALSE)  #
              return(u);#
          })#
#
###### HOSSFELD #######################################
#
#slightly different from one in main, since also getting variance + doing parameters on log scale#
wrapHossfeld. <- function(par, dataf) { #
    par <- exp(par)#
    pred <- Hossfeld(dataf$size, par[1:3]) #
    logLik <- dnorm(dataf$incr,pred,par[4], log=TRUE)#
    return(-sum(logLik[!is.na(dataf$incr) & !is.na(dataf$size)])) #
 } #
#
#
# Create wrapper to fit and return a Gompertz growth function#
getHossfeld <- function(dataf, par=c(0.002,0.01,1,1), plot=FALSE,...) {#
    tmp <- optim(par=log(par),wrapHossfeld., dataf=dataf, method="Nelder-Mead")  #
    gr1 <- new("growthObj.Hossfeld")#
    gr1@paras <- exp(tmp$par[1:3])#
    gr1@sd <- exp(tmp$par[4])#
    gr1@logLik <- -tmp$value#
#
    if(plot) {#
        pred <- Hossfeld(size=dataf$size,par=exp(tmp$par[1:3])) #
        plot(pred,dataf$incr,pch=19,ylab="Observed", xlab="Predicted",...)#, ylim=c(0,0.02))#
        abline(0,1,col=2)#
    }#
    return(gr1)#
}#
#
#
#
#
#
#
#
#
#
#
#### Function to fit all of these and compare likelihoods ####
#
likeCompGrowthMech <- function(dataf, plot=FALSE, plot.title=FALSE, xlims=c(0.1,10),ylims=c(-1,20)) {#
    #
    m1 <-  getPowerLaw(dataf=dataf, par=as.numeric(c(mean(dataf$incr/dataf$size,na.rm=TRUE),1,1)),#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Power Law")#
    legend("bottomleft",legend=paste("logLik=",round(m1@logLik,1)),bty="n", cex=0.8)#
#
    m2 <-  getMonomolecular(dataf=dataf,par=as.numeric(c(quantile(dataf$incr,0.975,na.rm=TRUE),#
                                        quantile(dataf$size,0.975,na.rm=TRUE),1)),#
                            plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Monomolecular")#
    legend("bottomleft",legend=paste("logLik=",round(m2@logLik,1)),bty="n", cex=0.8)#
#
    m3 <-  getGompertz(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Gompertz")#
    legend("bottomleft",legend=paste("logLik=",round(m3@logLik,1)),bty="n", cex=0.8)#
#
    m4 <-  getLogistic3(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Three parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m4@logLik,1)),bty="n", cex=0.8)#
#
    m5 <-  getLogistic4(dataf=dataf,#
                        plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Four parameter Logistic")#
    legend("bottomleft",legend=paste("logLik=",round(m5@logLik,1)),bty="n", cex=0.8)#
#
    m6 <-  getHossfeld(dataf=dataf,#
                       plot=plot,ylim=ylims)#, xlim=xlims);#
    if (plot.title) title("Hossfeld")#
    legend("bottomleft",legend=paste("logLik=",round(m6@logLik,1)),bty="n", cex=0.8)#
#
    #
    print("Comparison Gompertz and Logistic 3")#
    print(1-pchisq(-2*(m3@logLik-m4@logLik),1))#
    print("Comparison Logistic 4 and Logistic 3")#
    print(1-pchisq(-2*(m4@logLik-m5@logLik),1))#
    #
    return(list(m1=m1,m2=m2,m3=m3,m4=m4,m5=m5, m6=m6))#
    #
}
#
    #pic size, size next#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]+9]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic size, size next with density functions on#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dff$size,na.rm=TRUE), max(dff$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
#
        sizes <- seq(min(dff$size[dff$spcode==sp.list[j]],na.rm=TRUE),#
                       max(dff$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
  #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]+2]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]+4]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]+6]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]+8]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]+9]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
    #pic size, size next with density functions on#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dff$size,na.rm=TRUE), max(dff$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
#
        sizes <- seq(min(dff$size[dff$spcode==sp.list[j]],na.rm=TRUE),#
                       max(dff$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
  #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
sizes[chs[k]]+resp
chs
(sizes[chs])
#
    #pic size, size next with density functions on#
    par(mfrow=c(1,3),bty="l")#
    sizes <- seq(min(dff$size,na.rm=TRUE), max(dff$size,na.rm=TRUE),length=500)#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    scalar <- 100; minsc <- 0.0001#
   #
    for (j in 1:length(sp.list)) { #
        plot(dff$size[dff$spcode==sp.list[j]],dff$sizenext[dff$spcode==sp.list[j]], pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        mtext(sp.names[j])#
#
        sizes <- seq(min(dff$size[dff$spcode==sp.list[j]],na.rm=TRUE),#
                       max(dff$size[dff$spcode==sp.list[j]],na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
  #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m1)*scalar; resp[resp<minsc] <- NA   #Power Law#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m2)*scalar; resp[resp<minsc] <- NA   #Monomolecular#
            points(sizes[chs[k]]+resp,sizes, type="l", col=2)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m3)*scalar; resp[resp<minsc] <- NA   #Gompertz#
            points(sizes[chs[k]]+resp,sizes, type="l", col=3)                                #
            resp <- growth(sizes[chs[k]],sizes,1,res1$m4)*scalar; resp[resp<minsc] <- NA   #Logistic 3#
            points(sizes[chs[k]]+resp,sizes, type="l", col=4)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m5)*scalar; resp[resp<minsc] <- NA   #Logistic 4#
            points(sizes[chs[k]]+resp,sizes, type="l", col=5)#
            resp <- growth(sizes[chs[k]],sizes,1,res1$m6)*scalar; resp[resp<minsc] <- NA   #Hossfeld#
            points(sizes[chs[k]]+resp,sizes, type="l", col=6)#
            #
        }#
        if (j==1) legend("topleft", legend=c("Power Law", "Monomolecular",#
                                    "Gompertz", "Logistic 3 par", "Logistic 4 par", "Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        abline(0,1,lty=3)#
        #
    }
#
    #pic just of increments#
    chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
    par(mfrow=c(3,1), bty="l",pty="m")#
    scalar <- 1#
    for (j in 1:3) { #
        plot(sizes, sizes, ylim=c(0,0.35),#
             type="n", xlab="Size", ylab="Density in next time-step", xlim=range(sizes[c(chs+10,chs-10)]))#
        for (k in 1:length(chs)) {#
#
            if (j==1) res <- res1#
            if (j==2) res <- res2#
            if (j==3) res <- res3            #
                                        #Power Law#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m1)*scalar, type="l", col=1)#
                                        #Monomolecular#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m2)*scalar, type="l", col=2)#
                                        #Gompertz#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m3)*scalar, type="l", col=3)#
                                        #Logistic 3#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m4)*scalar, type="l", col=4)#
                                        #Logistic 4#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m5)*scalar, type="l", col=5)#
            points(sizes,#
                   growth(sizes[chs[k]],sizes,1,res$m6)*scalar, type="l", col=6)#
            #
        }#
        if (j==1) legend(110,0.35,#
            legend=c("Power Law", "Monomolecular","Gompertz", "Logistic 3 par", "Logistic 4 par","Hossfeld"),#
            lty=1, col=1:6, bty="n", cex=0.8)#
        mtext(sp.names[j])#
        abline(v=sizes[chs], lty=3)#
        #
    }
makeGrowthGeneral
makeGrowthObjGeneral
#
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE) {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType="sizenext",regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType="sizenext",regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType="sizenext",regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size3",#
                               responseType="sizenext",regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType="sizenext",regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType="sizenext",regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType="sizenext",regType="constantVar")#
#
    print(anova(m$fit,m0$fit,test="Chi"))#
    print(anova(m$fit,m0$fit,test="Chi"))#
  #
}
likeCompareClassicGrowthFits(dff)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE) {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType="sizenext",regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType="sizenext",regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType="sizenext",regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size3",#
                               responseType="sizenext",regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType="sizenext",regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType="sizenext",regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType="sizenext",regType="constantVar")#
#
    print(anova(m@fit,m0$@it,test="Chi"))#
    print(anova(m1@fit,m0@fit,test="Chi"))#
  #
}
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE) {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType="sizenext",regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType="sizenext",regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType="sizenext",regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size3",#
                               responseType="sizenext",regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType="sizenext",regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType="sizenext",regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType="sizenext",regType="constantVar")#
#
    print(anova(m@fit,m0$@fit,test="Chi"))#
    print(anova(m1@fit,m0@fit,test="Chi"))#
  #
}
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE) {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType="sizenext",regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType="sizenext",regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType="sizenext",regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size3",#
                               responseType="sizenext",regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType="sizenext",regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType="sizenext",regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType="sizenext",regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m1@fit,m0@fit,test="Chi"))#
  #
}
likeCompareClassicGrowthFits(dff)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
  #
}
likeCompareClassicGrowthFits(dff)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(size))#
        plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        points(sizes,predict(m$gr1,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0$gr1,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1$gr1,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2$gr1,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a$gr1,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a$gr1,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a$gr1,newdata=newd),type="l",col=3, lty=3)#
    #
#
    }#
#
    return(list(m=m))#
}
likeCompareClassicGrowthFits(dff)
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        points(sizes,predict(m$gr1,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0$gr1,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1$gr1,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2$gr1,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a$gr1,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a$gr1,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a$gr1,newdata=newd),type="l",col=3, lty=3)#
    #
#
    }#
#
    return(list(m=m))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
#
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
    #
#
    }#
#
    return(list(m=m))#
}
likeCompareClassicGrowthFits(dff,plot=T)
makeGrowthObjGeneral
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dff$incr <- (dff$sizenext-dff$size)#
    if (responseType=="logincr") dff$logincr <- log(dff$sizenext-dff$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m3=m3,m4=m4))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dff$incr <- (dff$sizenext-dff$size)#
    if (responseType=="logincr") dff$logincr <- log(dff$sizenext-dff$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dff$incr <- (dff$sizenext-dff$size)#
    if (responseType=="logincr") dff$logincr <- log(dff$sizenext-dff$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.01#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T)
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100000; minsc < 0.01#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T)
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 10; minsc < 0.01#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 10; minsc < 1e-6#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 1e-6#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=100)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA#
            print(range(sizes[chs[k]]+resp))#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc < 0.001#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA#
            print(range(sizes[chs[k]]+resp))#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc <- 1e-9#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 10; minsc <- 1e-9#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 10; minsc <- 1e-9#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; #resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; #resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; #resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 100; minsc <- 1e-9#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; #resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; #resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; #resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 500; minsc <- 1e-10#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; #resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; #resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; #resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
#
likeCompareClassicGrowthFits <- function(dataf, plot=FALSE,responseType="sizenext") {#
#
    #Function to create a time-scaled incr or log increment (the incr in the dataf is actually the "true"#
    # over the arbitrary census interval)#
    if (responseType=="incr") dataf$incr <- (dataf$sizenext-dataf$size)#
    if (responseType=="logincr") dataf$logincr <- log(dataf$sizenext-dataf$size)#
    #
    #do simple to complicated, and use parameters from previous as starting values#
    m <- makeGrowthObjGeneral(dataf,explanatoryVariables="1",#
                               responseType=responseType,regType="constantVar")#
    m0 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size",#
                               responseType=responseType,regType="constantVar")#
    m1 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2",#
                               responseType=responseType,regType="constantVar")#
    m2 <- makeGrowthObjGeneral(dataf,explanatoryVariables="size+size2+size3",#
                               responseType=responseType,regType="constantVar")#
    m0a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize",#
                               responseType=responseType,regType="constantVar")#
    m1a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size",#
                               responseType=responseType,regType="constantVar")#
    m2a <- makeGrowthObjGeneral(dataf,explanatoryVariables="logsize+size+size2",#
                               responseType=responseType,regType="constantVar")#
#
    print(anova(m@fit,m0@fit,test="Chi"))#
    print(anova(m0@fit,m1@fit,test="Chi"))#
    print(anova(m1@fit,m2@fit,test="Chi"))#
#
    print(anova(m@fit,m0a@fit,test="Chi"))#
    print(anova(m0a@fit,m1a@fit,test="Chi"))#
    print(anova(m1a@fit,m2a@fit,test="Chi"))#
#
#
    if (plot){#
        scalar <- 600; minsc <- 1e-20#
        sizes <- seq(min(dataf$size,na.rm=TRUE), max(dataf$size,na.rm=TRUE),length=500)#
        chs <- floor(quantile(1:length(sizes),c(0.2,0.4,0.6,0.8)))#
        newd<-data.frame(size=sizes,size2=sizes^2,size3=sizes^3,logsize=log(sizes))#
        if (responseType=="sizenext")#
            plot(dff$size,dff$sizenext, pch=19,col="grey", xlab="Size at t", ylab="Size at t+delta")#
        if (responseType=="incr")#
            plot(dff$size,dff$incr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType=="logincr")#
            plot(dff$size,dff$logincr, pch=19,col="grey", xlab="Size at t", ylab="Incr at t+delta")#
        if (responseType!="sizenext")points(sizes,predict(m@fit,newdata=newd),type="l",col=4, lty=2)#
        points(sizes,predict(m0@fit,newdata=newd),type="l",col=1, lty=2)#
        points(sizes,predict(m1@fit,newdata=newd),type="l",col=2, lty=2)#
        points(sizes,predict(m2@fit,newdata=newd),type="l",col=3, lty=2)#
        #points(sizes,predict(m0a@fit,newdata=newd),type="l",col=1, lty=3)#
        #points(sizes,predict(m1a@fit,newdata=newd),type="l",col=2, lty=3)#
        #points(sizes,predict(m2a@fit,newdata=newd),type="l",col=3, lty=3)#
        #
        for (k in 1:length(chs)) {#
            resp <- growth(sizes[chs[k]],sizes,1,m)*scalar; #resp[resp<minsc] <- NA   #
            if (responseType!="sizenext")#
                points(sizes[chs[k]]+resp,sizes, type="l", col=4, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m0)*scalar; #resp[resp<minsc] <- NA#
            print(sizes[chs[k]]+resp)#
            points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m1)*scalar; #resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=2)                                       #
            resp <- growth(sizes[chs[k]],sizes,1,m2)*scalar; resp[resp<minsc] <- NA   #
            points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=2)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m0a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=1, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m1a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=2, lty=3)                                       #
            #resp <- growth(sizes[chs[k]],sizes,1,m2a)*scalar; resp[resp<minsc] <- NA   #
            #points(sizes[chs[k]]+resp,sizes, type="l", col=3, lty=3)                                       #
        }#
          #
    }#
#
    return(list(m=m,m0=m0,m1=m1,m2=m2,m0a=m0a,m1a=m1a,m2a=m2a))#
}
likeCompareClassicGrowthFits(dff,plot=T,responseType="incr")
likeCompareClassicGrowthFits(dff,plot=T,responseType="sizenext")
?plot
?setMethod
?glm
promptClass()
promptClass(IPMmatrix)
?glm
?is.numeric
?lm
lm(dff$sizenext)
lm.D9 <- lm(weight ~ group)
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)#
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)#
group <- gl(2,10,20, labels=c("Ctl","Trt"))#
weight <- c(ctl, trt)#
lm.D9 <- lm(weight ~ group)
class(lm.D9)
slotNames(lm.D9)
str(lm.D9)
convertIncrement
?plot
?t
?lm-methods
?methods-lm
?methods-plot
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/TreesDemog-Impl.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/TreesDemog-Base.r")#
source("/Users/cjessicametcalf/Documents/workspace/IPMpack/pkg/R/TreesDemog-Util.r")
dff <- generateDataStoch()#
gr1 <- makeGrowthObjManyCov(dataf=dff,explanatoryVariables="size+covariate1+covariate2")#
sv1 <- makeSurvObjManyCov(dataf=dff,explanatoryVariables="size+covariate1+covariate3")#
fv1 <- makeFecObj(dff,1:3,1:3)
tvals <- seq(1,20,by=1/12)#
covtest <- (1+0.5*sin(2*pi*tvals))#
covmattest <- cbind(rnorm(length(covtest),covtest,0.5)-1,#
                    rnorm(length(covtest),covtest,0.5)-1,#
                    rnorm(length(covtest),covtest,0.5)-1)
r<-StochGrowthRateManyCov(covariate=covmattest,n.runin=12*10,Tmax=length(tvals),#
                          growthObj=gr1,survObj=sv1,fecObj=fv1,#
                          nBigMatrix=100,minsize=2*min(dff$size),maxsize=1.5*max(dff$size),n.microsites=10)#
print(r)
st<-TrackPopStructManyCov(covariate=covmattest,n.runin=12*10,Tmax=length(tvals),#
                          growthObj=gr1,survObj=sv1,fecObj=fv1,#
                          nBigMatrix=100,minsize=2*min(dff$size),maxsize=1.5*max(dff$size),#
                          n.microsites=10)
tvals <- seq(1,20,by=1/12)#
covtest <- (1+0.5*sin(2*pi*tvals))#
covmattest <- data.frame(covariate1=rnorm(length(covtest),covtest,0.5)-1,#
                    covariate2=rnorm(length(covtest),covtest,0.5)-1,#
                    covariate3=rnorm(length(covtest),covtest,0.5)-1)
r<-StochGrowthRateManyCov(covariate=covmattest,n.runin=12*10,Tmax=length(tvals),#
                          growthObj=gr1,survObj=sv1,fecObj=fv1,#
                          nBigMatrix=100,minsize=2*min(dff$size),maxsize=1.5*max(dff$size),n.microsites=10)
st<-TrackPopStructManyCov(covariate=covmattest,n.runin=12*10,Tmax=length(tvals),#
                          growthObj=gr1,survObj=sv1,fecObj=fv1,#
                          nBigMatrix=100,minsize=2*min(dff$size),maxsize=1.5*max(dff$size),#
                          n.microsites=10)
st<-TrackPopStructManyCov(covariate=covmattest,n.runin=2*4,Tmax=length(tvals),#
                          growthObj=gr1,survObj=sv1,fecObj=fv1,#
                          nBigMatrix=100,minsize=2*min(dff$size),maxsize=1.5*max(dff$size),#
                          n.microsites=10)
plotResultsStochStruct(tvals=tvals,st=st,covtest=covtest)
gr1 <- makeGrowthObjManyCov(dff,explanatoryVariables="size+covariate1+covariate2")#
sv1 <- makeSurvObjManyCov(dff,explanatoryVariables="size+covariate1+covariate3")#
fv1 <- makeFecObj(dff,c(1,3),c(1))
dff <- generateData()#
grlist <- makePostGrowthObjs(dff, nitt = 5000)#
svlist <- makePostSurvivalObjs(dff, nitt = 5000)
TmatrixList <- makeListTmatrix(grlist,svlist,nBigMatrix=20,minsize=-5,maxsize=35)
res <- getIPMoutput(TmatrixList, targetSize=5, Fmatrixlist=NULL)#
names(res)
res$LE
fv <- makePostFecObjs(dff, nitt=10000)#
FmatrixList <- makeListFmatrix(grlist,svlist,fv,nBigMatrix=20,minsize=-5,maxsize=35,cov=FALSE)#
res <- getIPMoutput(TmatrixList,targetSize=5,FmatrixList)
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975))), xlim=range(dff$size))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$ptime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5]),#
     ylim=range(quantile(res$ptime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],c(0.025,0.975))))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),type="l",lty=3)#
#
res$stable.size <- abs(Re(res$stable.size))#
res$stable.size <- res$stable.size/rowSums(res$stable.size)#
res$stable.size[!is.finite(res$stable.size) | is.na(res$stable.size)] <- 0#
CI <- apply(res$stable.size,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size), type="n",xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stable.size,c(0.025,0.975))))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size),type="l",lty=3)#
#
res$lambda[res$lambda<=0] <- NA#
hist(log(res$lambda),xlab=expression("Log "*lambda),ylab="",main="")
colMeans(res$ptime)
par(mfrow=c(2,2),bty="l")#
nmesh <- TmatrixList[[1]]@nBigMatrix#
CI <- apply(res$LE,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$LE), type="n",xlab="Size", ylab="Life expectancy",#
     ylim=range(quantile(res$LE,c(0.025,0.975), na.rm=TRUE)), xlim=range(dff$size,na.rm=TRUE))#
     #
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$LE),type="l",lty=3)#
#
CI <- apply(res$ptime,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),#
     type="n",xlab="Size", ylab="Passage time", xlim=range(dff$size[dff$size<5], na.rm=TRUE),#
     ylim=range(quantile(res$ptime[,TmatrixList[[1]]@meshpoints<max(dff$size,na.rm=T)],c(0.025,0.975),na.rm=TRUE)))#
#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$ptime),type="l",lty=3)#
#
res$stable.size <- abs(Re(res$stable.size))#
res$stable.size <- res$stable.size/rowSums(res$stable.size)#
res$stable.size[!is.finite(res$stable.size) | is.na(res$stable.size)] <- 0#
CI <- apply(res$stable.size,2,quantile,c(0.025,0.975))#
#
plot(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size), type="n",xlab="Size", ylab="Stable.size",#
     ylim=range(quantile(res$stable.size,c(0.025,0.975), na.rm=TRUE)))#
polygon(c(TmatrixList[[1]]@meshpoints)[c(1:nmesh,nmesh:1)],#
        c(CI[1,1:nmesh],CI[2,nmesh:1]),col="grey",border="white")#
points(TmatrixList[[1]]@meshpoints,colMeans(res$stable.size, na.rm=TRUE),type="l",lty=3)#
#
res$lambda[res$lambda<=0] <- NA#
hist(log(res$lambda),xlab=expression("Log "*lambda),ylab="",main="")
res$lambda
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
res <- getIPMoutput(TmatrixList,targetSize=5,FmatrixList)
hist(res$lambda,xlab=expression(lambda),ylab="",main="")
makeFecObj
?glm
